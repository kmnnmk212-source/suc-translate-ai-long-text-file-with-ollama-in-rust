# -*- coding: utf-8 -*-
"""suc_translatetextfile_rust_ai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TCKvMkzo-Ki9wIH3cVgSedWUXCd0Ekil
"""

!curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
import os
os.environ['PATH'] += ":/root/.cargo/bin"

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

import os

# Get the path to the home directory (e.g., /home/user)
home = os.path.expanduser("~")

# Define the Cargo bin path
cargo_path = os.path.join(home, ".cargo", "bin")

# Add it to the system PATH variable within this script
os.environ["PATH"] += os.pathsep + cargo_path

# ---------------------------------------------------------
# Now you can run your command successfully
# ---------------------------------------------------------
os.system("cargo --version")

!cargo

import os

# Get the path to the home directory (e.g., /home/user)
home = os.path.expanduser("~")

# Define the Cargo bin path
cargo_path = os.path.join(home, ".cargo", "bin")

# Add it to the system PATH variable within this script
os.environ["PATH"] += os.pathsep + cargo_path

# ---------------------------------------------------------
# Now you can run your command successfully
# ---------------------------------------------------------
os.system("cargo --version")

!cargo

!wget https://github.com/Michael-A-Kuykendall/shimmy/releases/download/v1.8.2/shimmy-linux-x86_64

!cargo add /content/shimmy-linux-x86_64

!cargo new a



from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd a

!cargo add /content/shimmy-linux-x86_64

!cargo install /content/shimmy-linux-x86_64

!cargo install /content/shimmy-linux-x86_64 --features huggingface

!!chmod +x /content/shimmy-linux-x86_64

!/content/shimmy-linux-x86_64 --help

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!./shimmy-linux-x86_64

!wget https://github.com/Michael-A-Kuykendall/shimmy/releases/download/v1.8.2/shimmy

!./shimmy --help

!!chmod +x ./shimmy

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!./shimmy --help

!./target/release/shimmy --help

!./content/shimmy-linux-x86_64





# Commented out IPython magic to ensure Python compatibility.
# %cd /content
!git clone https://github.com/hamaluik/translatetool.git

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/translatetool

!cargo build

!sudo apt-get install libssl-dev

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!curl -fsSL https://ollama.com/install.sh | sh

!ollama pull llama3:8b

!git clone https://github.com/iamkabelomoobi/rustlingo.git

# Commented out IPython magic to ensure Python compatibility.
# %cd rustlingo

# Commented out IPython magic to ensure Python compatibility.
# %%writefile /content/rustlingo/src/main.rs
# 
# 
# use std::env;
# use reqwest::Client;
# use serde_json::json;
# use tokio;
# 
# #[tokio::main]
# async fn main() -> Result<(), Box<dyn std::error::Error>> {
#     // 1. Ø£Ø®Ø° Ø§Ù„Ù†Øµ Ù…Ù† Ø³Ø·Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø±
#     let args: Vec<String> = env::args().collect();
#     if args.len() < 2 {
#         println!("Usage: rustlingo <word_or_sentence>");
#         return Ok(());
#     }
#     let input_text = &args[1];
# 
#     // 2. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª (Ø§Ù„Ø·Ù„Ø¨)
#     let prompt = format!(
#         "Explain the meaning, etymology, and usage of the word or phrase: '{}'. answer concisely.",
#         input_text
#     );
# 
#     // 3. Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Ollama (ØªØ£ÙƒØ¯ Ø£Ù† Ollama ÙŠØ¹Ù…Ù„)
#     let client = Client::new();
#     let res = client.post("http://localhost:11434/api/generate")
#         .json(&json!({
#             "model": "llama3:8b",  // ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ù‡Ù†Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ³ØªØ®Ø¯Ù… mistral Ø£Ùˆ ØºÙŠØ±Ù‡
#             "prompt": prompt,
#             "stream": false
#         }))
#         .send()
#         .await?;
# 
#     if res.status().is_success() {
#         let response_text = res.text().await?;
#         let response_json: serde_json::Value = serde_json::from_str(&response_text)?;
# 
#         if let Some(explanation) = response_json.get("response") {
#              println!("\nRUSTLINGO (Ollama):\n{}", explanation.as_str().unwrap_or("Error parsing response"));
#         }
#     } else {
#         println!("Error connecting to Ollama: {:?}", res.status());
#     }
# 
#     Ok(())
# }

!ollama list

!
!cargo build --release

!rustlingo --api-key "your-api-key-here" -i input.txt -o output.txt -l es

!./content/rustlingo/target/release/rustlingo --help

!./target/release/rustlingo --help

rustlingo [OPTIONS] --input <FILE> --output <FILE> --output-language <LANG>

!./target/release/rustlingo --input /content/1.txt --output /content/11.txt --output-language fr

"""### @@@@@@@@@@@@@@@@@@@@@@@Ø´ØºØ§Ù„"""

# Commented out IPython magic to ensure Python compatibility.
# 
# %%writefile /content/rustlingo/Cargo.toml
# 
# [package]
# name = "rustlingo"
# version = "0.1.0"
# edition = "2021"
# 
# [dependencies]
# clap = { version = "4.5", features = ["derive", "env"] }
# reqwest = { version = "0.12", features = ["json", "blocking", "rustls-tls"], default-features = false }
# serde = { version = "1.0", features = ["derive"] }
# serde_json = "1.0"
# tokio = { version = "1.40", features = ["full"] }
# anyhow = "1.0"
# url = "2.5"
# 
# 
# [dev-dependencies]
# tempfile = "3.13"
# Ù…ÙƒØªØ¨Ø© Ø¬Ø¯ÙŠØ¯Ø©

# Commented out IPython magic to ensure Python compatibility.
# %%writefile /content/rustlingo/src/main.rs
# 
# 
# use clap::Parser;
# use reqwest::Client;
# use serde_json::json;
# use std::fs;
# use std::io::Write;
# 
# // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªÙŠ ÙŠÙ‚Ø¨Ù„Ù‡Ø§ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬
# #[derive(Parser, Debug)]
# #[command(author, version, about, long_about = None)]
# struct Args {
#     /// Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
#     #[arg(short, long)]
#     input: String,
# 
#     /// Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
#     #[arg(short, long)]
#     output: String,
# 
#     /// Ø§Ù„Ù„ØºØ© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© (Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)
#     #[arg(long, default_value = "ar")]
#     output_language: String,
# }
# 
# #[tokio::main]
# async fn main() -> Result<(), Box<dyn std::error::Error>> {
#     // 1. Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù…Ù† Ø³Ø·Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø±
#     let args = Args::parse();
# 
#     println!("Reading file: {}", args.input);
# 
#     // 2. Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù†ØµÙŠ
#     let content = fs::read_to_string(&args.input)
#         .expect("Something went wrong reading the input file");
# 
#     if content.trim().is_empty() {
#         println!("The input file is empty!");
#         return Ok(());
#     }
# 
#     println!("Translating to: {}...", args.output_language);
# 
#     // 3. ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø·Ù„Ø¨ Ù„Ù€ Ollama
#     // ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª Ù‡Ù†Ø§ Ù„ÙŠÙ†Ø§Ø³Ø¨ Ø§Ø­ØªÙŠØ§Ø¬Ùƒ (ØªØ±Ø¬Ù…Ø©ØŒ ØªÙ„Ø®ÙŠØµØŒ Ø´Ø±Ø­...)
#     let prompt = format!(
#         "Translate the following text into {}, only provide the translation without introduction:\n\n{}",
#         args.output_language, content
#     );
# 
#     let client = Client::new();
#     let res = client.post("http://localhost:11434/api/generate")
#         .json(&json!({
#             "model": "llama3:8b", // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ø§Ù„Ù…Ø«Ø¨Øª Ù„Ø¯ÙŠÙƒ
#             "prompt": prompt,
#             "stream": false
#         }))
#         .send()
#         .await?;
# 
#     if res.status().is_success() {
#         let response_text = res.text().await?;
#         let response_json: serde_json::Value = serde_json::from_str(&response_text)?;
# 
#         if let Some(result_text) = response_json.get("response") {
#              let translated_text = result_text.as_str().unwrap_or("Error");
# 
#              // 4. Ø­ÙØ¸ Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
#              let mut file = fs::File::create(&args.output)?;
#              file.write_all(translated_text.as_bytes())?;
# 
#              println!("Done! Saved to: {}", args.output);
#              // Ø·Ø¨Ø§Ø¹Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØªØ£ÙƒØ¯
#              println!("Preview: {:.50}...", translated_text);
#         }
#     } else {
#         println!("Error connecting to Ollama: {:?}", res.status());
#     }
# 
#     Ok(())
# }

!ollama pull llama3:8b

!ollama list

!cargo build --release

!./target/release/rustlingo --input /content/1.txt --output /content/11.txt --output-language fr

/content/1.txt


Book Translator

A platform for translating books and large text documents.

Two-step process. For better quality.

The tool processes text files using Ollama LLM models with a two-stage approach: primary translation followed by AI self-reflection and refinement for better results. Suitable for translators, publishers, authors, researchers and content creators who need to translate large text documents.
Support for multiple languages including English, Russian, Spanish, French, German, Italian, Portuguese, Chinese, and Japanese. Genre-specific modes (fiction, technical, academic, business, poetry), real-time translation progress tracking for both stages, translation history and status monitoring, automatic error recovery and retry mechanisms, and multi-format export (TXT, PDF, EPUB).

/content/11.txt

Plateforme de traduction de livres et de documents texte importants.

ProcÃ©dure Ã  deux Ã©tapes. Pour une meilleure qualitÃ©.

L'outil traite les fichiers texte en utilisant des modÃ¨les LLM Ollama avec une approche Ã  deux Ã©tapes : traduction primaire suivie d'une rÃ©flexion et d'une mise Ã  jour automatique pour obtenir de meilleurs rÃ©sultats. AdÃ©quate pour les traducteurs, les Ã©diteurs, les auteurs, les chercheurs et les crÃ©ateurs de contenu qui doivent traduire des documents texte importants.
Prise en charge de plusieurs langues, notamment l'anglais, le russe, l'espagnol, le franÃ§ais, l'allemand, l'italien, le portugais, le chinois et le japonais. Modes d'affichage spÃ©cifiques au genre (fiction, technique, acadÃ©mique, commercial, poÃ©sie), suivi du progrÃ¨s de la traduction en temps rÃ©el pour les deux Ã©tapes, suivi de l'historique des traductions et du statut, mÃ©canismes de rÃ©cupÃ©ration automatique d'erreurs et de reprise, et export multiple format (TXT, PDF, EPUB).

/content/hello.txt


Hello, how are you?
This is a Rust translation test.
Welcome to RustLingo!

!./target/release/rustlingo --input /content/hello.txt --output /content/1ar1.txt --output-language ar

/content/1ar1.txt

Ù…Ø±Ø­Ø¨Ø§Ù‹ØŒ ÙƒÙŠÙ Ø­Ø§Ù„ÙƒØŸ

Ù‡Ø°Ø§ thá»­ nghiá»‡m Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø±ÙˆØ³ÙŠØ©.
Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒÙ… ÙÙŠ Ø±ÙˆØ³ Ù„ÙŠÙ†ØºÙˆ!

"""Ø©:

Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø§Ù„Ø°ÙŠ Ù‚Ù…Øª Ø¨Ø¨Ù†Ø§Ø¦Ù‡ ÙˆØªØ´ØºÙŠÙ„Ù‡ Ù†Ø§Ø¬Ø­ ØªÙ…Ø§Ù…Ù‹Ø§. Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¸Ø§Ù‡Ø±Ø© Ø£Ù…Ø§Ù…Ùƒ ØµØ§Ù„Ø­Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù‡Ù†ÙŠ ÙˆØªÙÙÙ‡Ù… Ø¨ÙˆØ¶ÙˆØ­ ØªØ§Ù… Ù…Ù† Ù‚Ø¨Ù„ Ø£ÙŠ Ù†Ø§Ø·Ù‚ Ø¨Ø§Ù„ÙØ±Ù†Ø³ÙŠØ©.

Ù†ØµÙŠØ­Ø© Ø¥Ø¶Ø§ÙÙŠØ©: Ø¬ÙˆØ¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© ØªØ¹ØªÙ…Ø¯ ÙƒÙ„ÙŠØ§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ø§Ù„Ø°ÙŠ ØªØ³ØªØ®Ø¯Ù…Ù‡ ÙÙŠ Ollama (Ù…Ø«Ù„ llama3 Ø£Ùˆ mistral Ø£Ùˆ gemma). Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª ØªØ­Ø³ÙŠÙ† Ø¯Ù‚Ø© Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§ØªØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø±Ø¨Ø© Ù…ÙˆØ¯ÙŠÙ„ Ø£ÙƒØ¨Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø£Ùˆ Ù…ÙˆØ¯ÙŠÙ„ Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©.
"""



"""### @@@@@@@@@@@@@@@@@@@@@Ø´ØºØ§Ù„"""







# Commented out IPython magic to ensure Python compatibility.
# %%writefile /content/translatetool/src/main.rs
# 
# 
# use clap::Parser;
# use reqwest::Client;
# use serde_json::json;
# use std::fs::{self, OpenOptions};
# use std::io::Write;
# use std::time::Duration;
# use tokio::time::sleep;
# 
# #[derive(Parser, Debug)]
# #[command(author, version, about, long_about = None)]
# struct Args {
#     #[arg(short, long)]
#     input: String,
# 
#     #[arg(short, long)]
#     output: String,
# 
#     #[arg(long, default_value = "ar")]
#     output_language: String,
# }
# 
# #[tokio::main]
# async fn main() -> Result<(), Box<dyn std::error::Error>> {
#     let args = Args::parse();
# 
#     println!("Reading file: {}", args.input);
#     let content = fs::read_to_string(&args.input)
#         .expect("Something went wrong reading the input file");
# 
#     if content.trim().is_empty() {
#         println!("File is empty.");
#         return Ok(());
#     }
# 
#     // 1. Ù…Ø³Ø­ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¥Ù† ÙˆØ¬Ø¯ Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯
#     fs::write(&args.output, "")?;
# 
#     // 2. ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙÙ‚Ø±Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø³Ø·Ø±ÙŠÙ† ÙØ§Ø±ØºÙŠÙ†
#     // Ù‡Ø°Ø§ ÙŠØ¶Ù…Ù† Ø£Ù†Ù†Ø§ Ù†Ø±Ø³Ù„ ÙÙ‚Ø±Ø© ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù…ÙˆØ¯ÙŠÙ„ ÙˆÙ„ÙŠØ³ Ø¬Ù…Ù„Ø§Ù‹ Ù…Ù‚Ø·ÙˆØ¹Ø©
#     let chunks: Vec<&str> = content.split("\n\n").collect();
#     let total_chunks = chunks.len();
# 
#     println!("Found {} paragraphs. Starting translation...", total_chunks);
# 
#     let client = Client::new();
# 
#     for (i, chunk) in chunks.iter().enumerate() {
#         if chunk.trim().is_empty() {
#             continue;
#         }
# 
#         println!("Translating paragraph {}/{}...", i + 1, total_chunks);
# 
#         let translated_text = translate_chunk(&client, chunk, &args.output_language).await;
# 
#         // 3. ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙˆØ±Ø§Ù‹ ÙÙŠ Ø§Ù„Ù…Ù„Ù (Append Mode)
#         let mut file = OpenOptions::new()
#             .write(true)
#             .append(true)
#             .open(&args.output)?;
# 
#         // Ù†Ø¶ÙŠÙ Ø³Ø·Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯ÙŠÙ† Ù„Ù„ÙØµÙ„ Ø¨ÙŠÙ† Ø§Ù„ÙÙ‚Ø±Ø§Øª
#         writeln!(file, "{}\n", translated_text)?;
#     }
# 
#     println!("------------------------------------------------");
#     println!("Done! Full translation saved to: {}", args.output);
#     Ok(())
# }
# 
# // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ±Ø¬Ù…Ø© Ù‚Ø·Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©
# async fn translate_chunk(client: &Client, text: &str, lang: &str) -> String {
#     let prompt = format!(
#         "Translate the following text into {}, keep the formatting, do not explain, just translate:\n\n{}",
#         lang, text
#     );
# 
#     // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø³ÙŠØ·Ø© ÙÙŠ Ø­Ø§Ù„ Ø§Ù„ÙØ´Ù„
#     let mut attempts = 0;
#     while attempts < 3 {
#         let res = client.post("http://localhost:11434/api/generate")
#             .json(&json!({
#                 "model": "llama3:8b", // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„
#                 "prompt": prompt,
#                 "stream": false
#             }))
#             .send()
#             .await;
# 
#         match res {
#             Ok(response) => {
#                 if let Ok(text) = response.text().await {
#                     if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
#                         if let Some(output) = json.get("response") {
#                             return output.as_str().unwrap_or("").to_string();
#                         }
#                     }
#                 }
#             }
#             Err(_) => {
#                 println!("Connection error, retrying...");
#             }
#         }
#         attempts += 1;
#         sleep(Duration::from_secs(2)).await; // Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
#     }
# 
#     return "[Translation Failed]".to_string();
# }

!cargo build --release

!./target/release/rustlingo --input /content/a.txt --output /content/aaaa.txt --output-language ar

"""Ø£ÙˆÙ„ cosa Ø¬Ø§Ø¡Øª Ù‡ÙŠ Ø§Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª ØªØ­Øª Ø§Ù„Ù…Ø§Ø¦ÙŠØ© Ø§Ù„ØªÙŠ ÙƒØ§Ù†Øªè¯•Øª Ù…Ø¹ ÙØ´Ù„ ØªÙØ¹ÙŠÙ„ Ù…Ø­ÙˆØ± Ø®Ø±ÙˆØ¬ 450 Ø·Ù†Ù‹Ø§ØŒ ÙˆÙ‡Ùˆ Ù…Ù†ÙØ° ÙÙŠ Ø±Ø£Ø³ Ø§Ù„Ù†ÙØ· Ø§Ù„Ø°ÙŠ ÙƒØ§Ù† supposed Ø£Ù† ÙŠØ®ØªØªÙ… Ø§Ù„ÙØªØ­ sudden change ÙÙŠ Ø§Ù„Ø¶ØºØ·. Ø«Ù… Ø¬Ø§Ø¡Øª Ø§Ù„Ø§Ø­ØªØ±Ø§Ù‚ kontrolled Ù„Ù„Ù†ÙØ· Ø§Ù„Ù…Ø¬Ù…Ø± Ø¹Ù„Ù‰ Ø³Ø·Ø­ Ø§Ù„Ù…Ø§Ø¡. ÙÙŠ 28 Ø£Ø¨Ø±ÙŠÙ„ØŒ Ø¨Ø¯Ø£ Ø£ÙØ±Ø§Ø¯ Ø§Ù„ÙØ±ÙŠÙ‚ Ø¥ØµÙ„Ø§Ø­ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹ØŒ ÙˆÙ‡ÙŠ ØªÙ‚Ù†ÙŠØ© ØªÙØ³ØªØ®Ø¯Ù… Ù„Ø­Ø±ÙƒØ© Ø®Ø²Ø§Ø¦Ù† Ù…ØªÙ…Ø±ÙƒØ²Ø© Ù…Ù† Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ù…Ù†ÙØµÙ„Ø© Ø­ÙŠØ« ÙŠÙIgnited. Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø£Ø®Ø±Ù‰ Ø´Ù…Ù„Øª Ø³Ù‚ÙˆØ· Ø§Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ø¯Ù…Ø¬ Ø¹Ù„Ù‰ Ø±Ø£Ø³ Ø§Ù„Ù†ÙØ· ÙˆØ§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù„Ù„unittesting Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø·Ø­ Ù„Ø¬Ù…Ø¹Ù‡Ø§. ÙˆÙ„ÙƒÙ† Ù…Ø¹ Ù…Ø±ÙˆØ± Ø§Ù„Ø£ÙŠØ§Ù…ØŒ Ù„Ø§ ÙŠØ²Ø§Ù„ Ø§Ù„Ù†ÙØ· ÙŠØªØ¯ÙÙ‚. ÙƒØ§Ù† Ø§Ù„Ù†ÙØ· ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ù…Ø­ØµÙˆØ±Ù‹Ø§ ÙÙŠ ÙŠÙˆÙ„ÙŠÙˆ Ø§Ù„Ù„Ø§Ø­Ù‚ Ø°Ù„Ùƒ Ø§Ù„Ø¹Ø§Ù…ØŒ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªØ±Ø§Ø¨ ÙˆØ«Ù…ØŒ Ø£Ø®ÙŠØ±Ù‹Ø§ØŒ Ø§Ù„Ø³Ù…Ù†Øª. ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø°ÙŠ Ù‚Ø§Ù… BP Ø¨ØªØºØ·ÙŠØ© Ø§Ù„Ù†ÙØ·ØŒ ÙÙ‚Ø¯ ÙØ¹Ù„Øª Ø¨Ø§Ù„ÙØ¹Ù„ 4,9 Ù…Ù„ÙŠÙˆÙ† Ø¨Ø±Ù…ÙŠÙ„ Ù…Ù† Ø§Ù„Ù†ÙØ·ØŒ Ø£Ùˆ 205,8 Ù…Ù„ÙŠÙˆÙ† ØºØ§Ù„ÙˆÙ†ØŒ ÙÙŠ ÑĞºÙˆØ³ÙŠØ³ØªÙŠÙ… Ù‡Ø´ Ø¹Ù„Ù‰ Ø³Ø§Ø­Ù„ Ù„ÙˆÙŠØ²ÙŠØ§Ù†Ø§. ÙˆÙ„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø´ÙŠØ¡ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙØ¹Ù„Ù‡ average American Ø¹Ù† Ø°Ù„Ùƒ.

Ø¨Ø¯Ø§ Ø£Ù† Ø§Ù„Ø®Ø¨Ø±Ø§Ø¡ - Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ÙˆÙ† Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙˆØ§Ù„Ø°ÙŠÙ†é›‡Ø¯Øª Ù…Ù† Ù‚Ø¨Ù„ Ø­ÙƒÙˆÙ…Ø© Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø© - Ù„Ù… ÙŠÙƒÙ† Ù„Ø¯ÙŠÙ‡Ù… ÙƒØ«Ø«ÙŠØ± Ù…Ù† Ø§Ù„Ø³ÙŠØ·Ø±Ø© Ø£ÙŠØ¶Ø§Ù‹. Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙƒØ§Ù†Øª Ø£ÙƒØ¨Ø± Ø§Ù„ÙƒÙˆØ§Ø±Ø« Ø§Ù„ØµÙ†Ø§Ø¹ÙŠØ© ÙÙŠ ØªØ§Ø±ÙŠØ® Ø£Ù…Ø±ÙŠÙƒØ§. Ø«Ù…ØŒ Ø¨Ø¹Ø¯ Ø£ÙŠØ§Ù… Ù‚Ù„ÙŠÙ„Ø© Ù…Ù† Ø¹Ù†Ø¯Ù…Ø§ ØªÙ… ÙˆØ¶Ø¹ Ø§Ù„Ø¨Ø±ØºÙŠ Ø§Ù„Ø³Ù…Ù†ØªÙŠØ© ï¬nallyØŒ Ø£Ø¹Ù„Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ Ø£ÙˆØ¨Ø§Ù…Ø§ Ø£Ù† Ù†ØµÙ Ø§Ù„Ù†ÙØ· Ø§Ù„Ù…Ù…Ø²Ù‚ Ù‚Ø¯ ÙÙØ±Ø¶ Ø£Ùˆ ØªÙ… Ø¥Ø²Ø§Ù„ØªÙ‡ Ø¨ÙˆØ§Ø³Ø·Ø© ÙØ±Ù‚ Ø§Ù„Ù†Ø¸Ø§ÙØ©.

ÙˆÙ„ÙƒÙ† Ø­ØªÙ‰ Ø§Ù„Ø£ÙƒØ«Ø±credulous Ù…Ù† Ø®Ø¨Ø±Ø§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹Ø© Ø§Ù„Ù†ÙØ·ÙŠØ© Ù„Ø¯ÙŠÙ‡Ù… ØµØ¹ÙˆØ¨Ø© ÙÙŠ Ø§Ù„Ø¥ÙŠÙ…Ø§Ù† Ø¨Ø£Ù† Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ÙƒØ§Ø±Ø«Ø© ÙƒØ§Ù†Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø³Ù‡ÙˆÙ„Ø©. Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ ÙˆÙ…Ø¹ Ø°Ù„ÙƒØŒ ÙØ¥Ù† Ø§Ù„ÙÙ‡Ù… Ø§Ù„Ø°ÙŠ Ø¹Ø±ÙÙ‡ Ø§Ù„Ù†Ø§Ø³ Ù‡Ùˆ Ø£Ù† ingenuity Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ© ÙØ´Ù„Øª ÙÙŠ ÙˆÙ‚Øª ÙƒØ¨ÙŠØ±. ÙÙŠ Ù†Ù…ÙˆØ°Ø¬ tinkering Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØŒ ÙŠØ¬Ø¨ Ø£Ù† ÙŠemerger Brilliant ÙØ±Ø¯ ÙˆÙŠØ¬Ø¯ Ø­Ù„ Ø¨Ø±iliant Ø£Ù‚ÙØµØ±Ù‡. ÙˆÙ„ÙƒÙ† Ù„Ù… ÙŠØ­Ø¯Ø« Ø°Ù„Ùƒ. Ø§Ù„Ø­Ø§Ø¯Ø«Ø© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ù„Ø§Ø§Ø³ØªÙ„Ø²Ù… Ø§Ù„Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ù„Ø§Ø²Ù…. Ø¨Ø¯Ù„ Ù…Ù† Ø±ÙØ¹ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙˆØ¹ÙŠ Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©ØŒ Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø© Ù‡ÙŠ Ø§Ù„ØªÙŠ Ù‚Ø§Ù…Øª Ø¨Ø£Ø¹Ø¸Ù… Ø¬Ù‡Ø¯ Ù„Ø®ÙÙŠÙ‚ Ù…Ø³Ø§Ø±Ù‡Ø§ ÙˆØ§Ù„Ø´Ùƒ Ø£Ù† Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù„ÙŠØ³Øª Ø­ØªÙ‰ Ù…Ø´ÙƒÙ„Ø©.

12

...
"""

code Bash


!ollama pull aya
# Ø£Ùˆ
!ollama pull gemma2



Ù†ØµÙŠØ­Ø©: Ø£Ù†ØµØ­ Ø¨Ù€ aya Ù„Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.

!ollama pull aya

"""Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨ØªØ¹Ø¯ÙŠÙ„ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ù„ØªØ¬Ø¨Ø± Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØµØ±Ù ÙƒÙ€ "Ù…ØªØ±Ø¬Ù… Ù…Ø­ØªØ±Ù" ÙˆÙ…Ù†Ø¹ Ø®Ù„Ø· Ø§Ù„Ù„ØºØ§Øª."""

!ollama list

# Commented out IPython magic to ensure Python compatibility.
# %%writefile /content/rustlingo/src/main.rs
# 
# 
# use clap::Parser;
# use reqwest::Client;
# use serde_json::json;
# use std::fs::{self, OpenOptions};
# use std::io::Write;
# use std::time::Duration;
# use tokio::time::sleep;
# 
# #[derive(Parser, Debug)]
# #[command(author, version, about, long_about = None)]
# struct Args {
#     #[arg(short, long)]
#     input: String,
# 
#     #[arg(short, long)]
#     output: String,
# 
#     /// Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ (Ù…Ø«Ù„Ø§: aya, gemma2, llama3)
#     #[arg(short, long, default_value = "aya:latest")]
#     model: String,
# 
#     #[arg(long, default_value = "ar")]
#     output_language: String,
# }
# 
# #[tokio::main]
# async fn main() -> Result<(), Box<dyn std::error::Error>> {
#     let args = Args::parse();
# 
#     println!("Reading file: {}", args.input);
#     let content = fs::read_to_string(&args.input)
#         .expect("Something went wrong reading the input file");
# 
#     if content.trim().is_empty() {
#         println!("File is empty.");
#         return Ok(());
#     }
# 
#     fs::write(&args.output, "")?;
# 
#     // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ
#     let chunks: Vec<&str> = content.split("\n\n").collect();
#     let total_chunks = chunks.len();
# 
#     println!("Using Model: {}", args.model);
#     println!("Translating {} paragraphs...", total_chunks);
# 
#     let client = Client::new();
# 
#     for (i, chunk) in chunks.iter().enumerate() {
#         if chunk.trim().is_empty() {
#             continue;
#         }
# 
#         println!("Translating paragraph {}/{}...", i + 1, total_chunks);
# 
#         let translated_text = translate_chunk(&client, chunk, &args.output_language, &args.model).await;
# 
#         let mut file = OpenOptions::new()
#             .write(true)
#             .append(true)
#             .open(&args.output)?;
# 
#         writeln!(file, "{}\n", translated_text)?;
#     }
# 
#     println!("Done! Saved to: {}", args.output);
#     Ok(())
# }
# 
# async fn translate_chunk(client: &Client, text: &str, lang: &str, model: &str) -> String {
#     // Ø¨Ø±ÙˆÙ…Ø¨Øª Ù…Ø­Ø³Ù‘Ù† Ø¬Ø¯Ø§Ù‹ ÙŠÙ…Ù†Ø¹ Ø§Ù„Ù‡Ù„ÙˆØ³Ø©
#     let prompt = format!(
#         "You are a professional translator. Translate the following text into Arabic ({}). \
#         Requirements:\
#         1. Translate accurately and naturally.\
#         2. Do NOT mix English words in the output.\
#         3. Do NOT add explanations or notes.\
#         4. Translate technical terms to their correct Arabic equivalents.\
#         \
#         Text to translate:\n\n{}",
#         lang, text
#     );
# 
#     let mut attempts = 0;
#     while attempts < 3 {
#         let res = client.post("http://localhost:11434/api/generate")
#             .json(&json!({
#                 "model": model,
#                 "prompt": prompt,
#                 "stream": false,
#                 "temperature": 0.3 // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø±Ø§Ø±Ø© Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¯Ù‚Ø© ÙˆØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù‡Ù„ÙˆØ³Ø©
#             }))
#             .send()
#             .await;
# 
#         match res {
#             Ok(response) => {
#                 if let Ok(text) = response.text().await {
#                     if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
#                         if let Some(output) = json.get("response") {
#                             return output.as_str().unwrap_or("").to_string();
#                         }
#                     }
#                 }
#             }
#             Err(_) => {
#                 println!("Connection error, retrying...");
#             }
#         }
#         attempts += 1;
#         sleep(Duration::from_secs(2)).await;
#     }
# 
#     return "[Translation Failed]".to_string();
# }

!!cargo build --release

!cargo build --release

!./target/release/rustlingo --input /content/a.txt --output /content/aa111.txt --output-language ar

!./target/release/rustlingo --input /content/a.txt --output /content/1az1.txt --model  aya:latest

import time
import subprocess

# 1. ØªØ´ØºÙŠÙ„ Ollama ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© (Ø¨Ø´ÙƒÙ„ ÙŠØ¶Ù…Ù† Ø¨Ù‚Ø§Ø¡Ù‡ ÙŠØ¹Ù…Ù„)
print("ğŸ”„ Starting Ollama server...")
subprocess.Popen(["ollama", "serve"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# 2. Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø­ØªÙ‰ ÙŠØ¹Ù…Ù„ Ø§Ù„Ø®Ø§Ø¯Ù…
time.sleep(5)

# 3. Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ¯ÙŠÙ„ aya (Ø£Ùˆ ØªØ­Ù…ÙŠÙ„Ù‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹)
print("ğŸ“¥ Checking/Pulling Model 'aya'...")
!ollama pull aya

# 4. ØªØ´ØºÙŠÙ„ Ø£Ø¯Ø§Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ø§Ù„Ø¢Ù†
print("ğŸš€ Starting Translation...")
!./target/release/rustlingo --input /content/1.txt --output /content/11.txt --model aya

# 5. Ø¹Ø±Ø¶ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØªØ£ÙƒØ¯
print("âœ… Done! Preview of result:")
!head -n 10 /content/11.txt

import time
import subprocess

# 1. ØªØ´ØºÙŠÙ„ Ollama ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© (Ø¨Ø´ÙƒÙ„ ÙŠØ¶Ù…Ù† Ø¨Ù‚Ø§Ø¡Ù‡ ÙŠØ¹Ù…Ù„)
print("ğŸ”„ Starting Ollama server...")
subprocess.Popen(["ollama", "serve"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# 2. Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø­ØªÙ‰ ÙŠØ¹Ù…Ù„ Ø§Ù„Ø®Ø§Ø¯Ù…
time.sleep(5)

# 3. Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ¯ÙŠÙ„ aya (Ø£Ùˆ ØªØ­Ù…ÙŠÙ„Ù‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹)
print("ğŸ“¥ Checking/Pulling Model 'aya'...")
!ollama pull aya

# 4. ØªØ´ØºÙŠÙ„ Ø£Ø¯Ø§Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ø§Ù„Ø¢Ù†
print("ğŸš€ Starting Translation...")
!./target/release/rustlingo --input /content/a.txt --output /content/1aaaaaa1.txt --model aya

# 5. Ø¹Ø±Ø¶ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØªØ£ÙƒØ¯
print("âœ… Done! Preview of result:")
!head -n 10 /content/11.txt

!head -n 10 /content/a.txt

This fundamental misreading of the tinkererâ€™s outlook suggests that
another way of telling the story of the modern tinkerer is required.
This book intends to serve as that alternate history. Throughout this
book, I will explore the work and mindsets of various modern tinker-
ers. Some are self-selecting, having presented themselves as the con-
temporary analogues to Franklin and Edison. Others would never
think of themselves as anything as grandiose as that. Indeed, these
secret tinkerers generally view their work as far from extraordinary.
They are simply getting a job done in the best way they know how.
Surface tinkering versus deeply probing tinkering is another di-
chotomy I set out to contrast in these pages. A common complaint
among those who worry about the future of innovation in American
society is that todayâ€™s young people arenâ€™t motivated to tinker in the
way their forbears were. It occurred to me along the way that many of
Americaâ€™s best-known tinkerers were not responding to any stimulus
beyond their own curiosity. Truly impassioned tinkerers do what they
do because itâ€™s fun, not because someone is dangling an incentive in
front of them. (Gever Tulley, founder of the Tinkering School in San
Francisco, California, whose story is told later in this book, knows
this and has built his experimental educational programs around it.)
As a result, some tinkering is debunked as mere careerism in the fol-
lowing pages and some is revealed as hidden tinkering, or tinkering
in the rough. Surface tinkerers make a big show of their methods,
process, and the fabulous end products of their tinkering, whereas
deeply probing tinkerers produce innovative thought regardless of
the medium, changing the way we think about thinking about things.

!ollama pull aya:8b

!ollama list

# Commented out IPython magic to ensure Python compatibility.
# %%writefile /content/translatetool/src/main.rs
# 
# 
# 
# use clap::Parser;
# use reqwest::Client;
# use serde_json::json;
# use std::fs::{self, OpenOptions};
# use std::io::Write;
# use std::time::Duration;
# use tokio::time::sleep;
# 
# #[derive(Parser, Debug)]
# #[command(author, version, about, long_about = None)]
# struct Args {
#     #[arg(short, long)]
#     input: String,
# 
#     #[arg(short, long)]
#     output: String,
# 
#     #[arg(short, long, default_value = "llama3:8b")]
#     model: String,
# 
#     #[arg(long, default_value = "ar")]
#     output_language: String,
# }
# 
# #[tokio::main]
# async fn main() -> Result<(), Box<dyn std::error::Error>> {
#     let args = Args::parse();
# 
#     println!("Reading file: {}", args.input);
#     let content = fs::read_to_string(&args.input)
#         .expect("Something went wrong reading the input file");
# 
#     if content.trim().is_empty() {
#         println!("File is empty.");
#         return Ok(());
#     }
# 
#     fs::write(&args.output, "")?;
# 
#     // --- Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø¬Ø°Ø±ÙŠ Ù‡Ù†Ø§: ØªÙ‚Ø³ÙŠÙ… Ø°ÙƒÙŠ Ù„Ù„Ù†Øµ ---
#     // Ù†Ù‚Ø³Ù… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ Ù‚Ø·Ø¹ Ù„Ø§ ØªØªØ¬Ø§ÙˆØ² 1500 Ø­Ø±Ù Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªÙˆÙ‚Ù Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„
#     let chunks = split_text_smartly(&content, 1500);
#     let total_chunks = chunks.len();
# 
#     println!("Using Model: {}", args.model);
#     println!("Text split into {} chunks (limit 1500 chars). Starting...", total_chunks);
# 
#     // Ø²ÙŠØ§Ø¯Ø© Ù…Ù‡Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± (Timeout) Ø¥Ù„Ù‰ 5 Ø¯Ù‚Ø§Ø¦Ù‚
#     let client = Client::builder()
#         .timeout(Duration::from_secs(300))
#         .build()?;
# 
#     for (i, chunk) in chunks.iter().enumerate() {
#         println!("Translating part {}/{} ({} chars)...", i + 1, total_chunks, chunk.len());
# 
#         let translated_text = translate_chunk(&client, chunk, &args.output_language, &args.model).await;
# 
#         let mut file = OpenOptions::new()
#             .write(true)
#             .append(true)
#             .open(&args.output)?;
# 
#         writeln!(file, "{}\n", translated_text)?;
#     }
# 
#     println!("Done! Saved to: {}", args.output);
#     Ok(())
# }
# 
# // Ø¯Ø§Ù„Ø© Ù„ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø§Ù„Ø·ÙˆÙŠÙ„ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¬Ù… ÙˆÙ†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¬Ù…Ù„
# fn split_text_smartly(text: &str, max_len: usize) -> Vec<String> {
#     let mut chunks = Vec::new();
#     let mut current_chunk = String::new();
# 
#     // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ù„Ø¹Ø¯Ù… Ù‚Ø·Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª
#     let words: Vec<&str> = text.split_whitespace().collect();
# 
#     for word in words {
#         if current_chunk.len() + word.len() + 1 > max_len {
#             // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ØŒ Ù†Ø­ÙØ¸ Ø§Ù„Ù‚Ø·Ø¹Ø© ÙˆÙ†Ø¨Ø¯Ø£ Ø¬Ø¯ÙŠØ¯Ø©
#             chunks.push(current_chunk.trim().to_string());
#             current_chunk = String::new();
#         }
#         current_chunk.push_str(word);
#         current_chunk.push(' ');
# 
#         // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù…Ù„Ø© Ø¨Ù†Ù‚Ø·Ø©ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡Ø§ Ù†Ù‚Ø·Ø© ÙØµÙ„ Ù…ÙØ¶Ù„Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
#         // Ù„ÙƒÙ† Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ø£Ù‡Ù… Ù‡Ùˆ Ø§Ù„Ø·ÙˆÙ„ (max_len)
#     }
# 
#     if !current_chunk.trim().is_empty() {
#         chunks.push(current_chunk.trim().to_string());
#     }
# 
#     chunks
# }
# 
# async fn translate_chunk(client: &Client, text: &str, lang: &str, model: &str) -> String {
#     let prompt = format!(
#         "Translate the following text into Arabic ({}). Output ONLY the translation without any introduction or notes.\n\nText:\n{}",
#         lang, text
#     );
# 
#     let mut attempts = 0;
#     while attempts < 3 {
#         let res = client.post("http://localhost:11434/api/generate")
#             .json(&json!({
#                 "model": model,
#                 "prompt": prompt,
#                 "stream": false,
#                 "options": {
#                     "num_ctx": 4096 // Ø²ÙŠØ§Ø¯Ø© Ù†Ø§ÙØ°Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ Ù„Ù„Ù…ÙˆØ¯ÙŠÙ„
#                 }
#             }))
#             .send()
#             .await;
# 
#         match res {
#             Ok(response) => {
#                 if response.status().is_success() {
#                     if let Ok(text_resp) = response.text().await {
#                         if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text_resp) {
#                             if let Some(output) = json.get("response") {
#                                 return output.as_str().unwrap_or("").to_string();
#                             }
#                         }
#                     }
#                 } else {
#                      println!("Server error: {:?}", response.status());
#                 }
#             }
#             Err(e) => {
#                 println!("Connection error: {}, retrying...", e);
#             }
#         }
#         attempts += 1;
#         sleep(Duration::from_secs(3)).await;
#     }
# 
#     return format!("[FAILED CHUNK: {}...]", &text.chars().take(50).collect::<String>());
# }

!cargo build --release

!./target/release/rustlingo --input /content/a.txt --output /content/11q.txt --model llama3:8b

!ollama list

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/rustlingo

import os
import subprocess
import time
import requests

# === 1. ÙƒØªØ§Ø¨Ø© ÙƒÙˆØ¯ Rust Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ø§Ù„Ø°ÙŠ ÙŠØ¯Ø¹Ù… ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ ÙˆØ§Ù„ØªØ¹Ø§ÙÙŠ Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡) ===
rust_code = """
use clap::Parser;
use reqwest::Client;
use serde_json::json;
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long)]
    input: String,
    #[arg(short, long)]
    output: String,
    #[arg(short, long, default_value = "aya:8b")]
    model: String,
    #[arg(long, default_value = "ar")]
    output_language: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
    if !std::path::Path::new(&args.input).exists() {
        eprintln!("Error: Input file not found: {}", args.input);
        return Ok(());
    }

    let content = fs::read_to_string(&args.input).expect("Failed to read file");
    fs::write(&args.output, "")?;

    // ØªÙ‚Ø³ÙŠÙ… Ø°ÙƒÙŠ (ÙƒÙ„ 1000 Ø­Ø±Ù ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹)
    let chunks = split_text_smartly(&content, 1000);
    let total_chunks = chunks.len();

    println!("Model: {}, Chunks: {}", args.model, total_chunks);

    let client = Client::builder().timeout(Duration::from_secs(120)).build()?;

    for (i, chunk) in chunks.iter().enumerate() {
        println!("Translating chunk {}/{} ({} chars)...", i + 1, total_chunks, chunk.len());

        let translated = translate_chunk(&client, chunk, &args.output_language, &args.model).await;

        let mut file = OpenOptions::new().write(true).append(true).open(&args.output)?;
        writeln!(file, "{}\\n", translated)?;
    }
    println!("âœ… Done! Saved to {}", args.output);
    Ok(())
}

fn split_text_smartly(text: &str, max_len: usize) -> Vec<String> {
    let mut chunks = Vec::new();
    let mut current = String::new();
    for word in text.split_whitespace() {
        if current.len() + word.len() > max_len {
            chunks.push(current.trim().to_string());
            current = String::new();
        }
        current.push_str(word);
        current.push(' ');
    }
    if !current.trim().is_empty() { chunks.push(current.trim().to_string()); }
    chunks
}

async fn translate_chunk(client: &Client, text: &str, lang: &str, model: &str) -> String {
    let prompt = format!("Translate into Arabic ({}). No preamble. Text:\\n{}", lang, text);
    let mut attempts = 0;
    while attempts < 5 { // 5 Ù…Ø­Ø§ÙˆÙ„Ø§Øª
        let res = client.post("http://localhost:11434/api/generate")
            .json(&json!({ "model": model, "prompt": prompt, "stream": false }))
            .send().await;

        if let Ok(resp) = res {
            if let Ok(txt) = resp.text().await {
                if let Ok(j) = serde_json::from_str::<serde_json::Value>(&txt) {
                    if let Some(out) = j.get("response") { return out.as_str().unwrap_or("").to_string(); }
                }
            }
        }
        eprintln!("âš ï¸ Retry {}/5...", attempts + 1);
        sleep(Duration::from_secs(2)).await;
        attempts += 1;
    }
    format!("[FAILED CHUNK]")
}
"""

# Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ù„Ù
with open("src/main.rs", "w") as f:
    f.write(rust_code)
print("âœ… Code updated successfully.")

# === 2. Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ (Rebuild) ===
print("ğŸ”¨ Building Rust binary (this may take a minute)...")
subprocess.run("cargo clean", shell=True, check=True) # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
subprocess.run("cargo build --release", shell=True, check=True)
print("âœ… Build complete.")

# === 3. Ø¥Ø¹Ø¯Ø§Ø¯ Ø®Ø§Ø¯Ù… Ollama ===
print("ğŸ”„ Restarting Ollama server...")
os.system("pkill ollama") # Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ Ù†Ø³Ø®Ø© Ù‚Ø¯ÙŠÙ…Ø©
time.sleep(2)
subprocess.Popen("ollama serve", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
time.sleep(5) # Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨Ø¯Ø¡

# === 4. Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ ÙˆØ§Ù„Ø§ØªØµØ§Ù„ ===
print("ğŸ“¡ Checking connection to Ollama...")
try:
    requests.get("http://localhost:11434")
    print("âœ… Ollama is Online!")
except:
    print("âŒ Ollama is NOT responding! script will fail.")

print("ğŸ“¥ Pulling model 'aya'...")
os.system("ollama pull aya")

# === 5. ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø© ===
print("ğŸš€ Starting Translator...")
# ØªØ£ÙƒØ¯ Ù…Ù† ØªØºÙŠÙŠØ± Ø§Ø³Ù… Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø¨Ù…Ø§ ÙŠÙ†Ø§Ø³Ø¨Ùƒ
input_file = "/content/a.txt" # Ù…Ù„ÙÙƒ
output_file = "/content/11.txt"

if not os.path.exists(input_file):
    print(f"âŒ Error: Input file {input_file} not found!")
else:
    cmd = f"./target/release/rustlingo --input {input_file} --output {output_file} --model aya"
    os.system(cmd)

    # Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    if os.path.exists(output_file):
        print("\n--- Translation Preview ---")
        os.system(f"head -n 5 {output_file}")

!ollama list

import os
import subprocess
import time
import requests

# === 1. Ø¥ØµÙ„Ø§Ø­ Ù…Ø³Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… (Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø£Ù‡Ù… Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© 127) ===
# Ù†Ø¶ÙŠÙ Ù…Ø³Ø§Ø± Rust ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„ÙŠØ¹Ø±Ù Ø§Ù„Ù†Ø¸Ø§Ù… Ø£ÙŠÙ† ÙŠØ¬Ø¯ cargo
os.environ['PATH'] += ":/root/.cargo/bin"

# Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù†Ø§ Ø¯Ø§Ø®Ù„ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
project_dir = "/content/rustlingo"
if not os.path.exists(project_dir):
    print("âš ï¸ Project folder not found, cloning it...")
    subprocess.run("git clone https://github.com/iamkabelomoobi/rustlingo /content/rustlingo", shell=True)

os.chdir(project_dir)
print(f"ğŸ“‚ Working directory: {os.getcwd()}")

# === 2. ÙƒØªØ§Ø¨Ø© ÙƒÙˆØ¯ Rust Ø§Ù„Ø¬Ø¯ÙŠØ¯ (ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ + Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡) ===
rust_code = """
use clap::Parser;
use reqwest::Client;
use serde_json::json;
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long)]
    input: String,
    #[arg(short, long)]
    output: String,
    #[arg(short, long, default_value = "aya:8b")]
    model: String,
    #[arg(long, default_value = "ar")]
    output_language: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    if !std::path::Path::new(&args.input).exists() {
        eprintln!("Error: Input file not found: {}", args.input);
        return Ok(());
    }

    let content = fs::read_to_string(&args.input).expect("Failed to read file");
    // ØªÙ†Ø¸ÙŠÙ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
    fs::write(&args.output, "")?;

    // ØªÙ‚Ø³ÙŠÙ… ÙƒÙ„ 1500 Ø­Ø±Ù Ù„Ø¶Ù…Ø§Ù† Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„
    let chunks = split_text_smartly(&content, 1500);
    let total_chunks = chunks.len();

    println!("Using Model: {}, Total Chunks: {}", args.model, total_chunks);

    let client = Client::builder().timeout(Duration::from_secs(180)).build()?;

    for (i, chunk) in chunks.iter().enumerate() {
        println!("Translating chunk {}/{} ({} chars)...", i + 1, total_chunks, chunk.len());

        let translated = translate_chunk(&client, chunk, &args.output_language, &args.model).await;

        let mut file = OpenOptions::new().write(true).append(true).open(&args.output)?;
        writeln!(file, "{}\\n", translated)?;
    }
    println!("âœ… Done! Saved to {}", args.output);
    Ok(())
}

fn split_text_smartly(text: &str, max_len: usize) -> Vec<String> {
    let mut chunks = Vec::new();
    let mut current = String::new();
    for word in text.split_whitespace() {
        if current.len() + word.len() > max_len {
            chunks.push(current.trim().to_string());
            current = String::new();
        }
        current.push_str(word);
        current.push(' ');
    }
    if !current.trim().is_empty() { chunks.push(current.trim().to_string()); }
    chunks
}

async fn translate_chunk(client: &Client, text: &str, lang: &str, model: &str) -> String {
    let prompt = format!("Translate the following text into Arabic ({}). Output ONLY the translation. Text:\\n{}", lang, text);
    let mut attempts = 0;
    while attempts < 5 {
        let res = client.post("http://localhost:11434/api/generate")
            .json(&json!({ "model": model, "prompt": prompt, "stream": false }))
            .send().await;

        if let Ok(resp) = res {
            if let Ok(txt) = resp.text().await {
                if let Ok(j) = serde_json::from_str::<serde_json::Value>(&txt) {
                    if let Some(out) = j.get("response") { return out.as_str().unwrap_or("").to_string(); }
                }
            }
        }
        eprintln!("âš ï¸ Connection/Model error. Retrying {}/5...", attempts + 1);
        sleep(Duration::from_secs(3)).await;
        attempts += 1;
    }
    format!("[FAILED CHUNK]")
}
"""

with open("src/main.rs", "w") as f:
    f.write(rust_code)
print("âœ… Rust code updated.")

# === 3. Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ===
print("ğŸ”¨ Building binary...")
# Ù†ØªØ¬Ø§Ù‡Ù„ cargo clean Ù„ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ØŒ ÙˆÙ†Ù‚ÙˆÙ… Ø¨Ø§Ù„Ø¨Ù†Ø§Ø¡ Ù…Ø¨Ø§Ø´Ø±Ø©
subprocess.run("cargo build --release", shell=True, check=True)
print("âœ… Build success.")

# === 4. ØªØ¬Ù‡ÙŠØ² Ollama ===
print("ğŸ”„ Preparing Ollama...")
os.system("pkill ollama")
time.sleep(2)
subprocess.Popen("ollama serve", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
time.sleep(5)

print("ğŸ“¥ Ensuring model 'aya' is ready...")
# Ù†ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ù…ÙˆØ¬ÙˆØ¯
subprocess.run("ollama pull aya", shell=True)

# === 5. Ø§Ù„ØªØ´ØºÙŠÙ„ ===
input_file = "/content/a.txt"  # ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù…Ù„Ù a.txt Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³Ø§Ø±
output_file = "/content/11.txt"

print(f"ğŸš€ Starting translation of {input_file}...")
if os.path.exists(input_file):
    cmd = f"./target/release/rustlingo --input {input_file} --output {output_file} --model aya:8b"
    subprocess.run(cmd, shell=True)

    print("\n--- Preview ---")
    if os.path.exists(output_file):
        os.system(f"head -n 5 {output_file}")
else:
    print(f"âŒ Error: The file {input_file} does not exist! Upload it first.")

"""
ÙƒØ§Ù† Ø§Ù„ÙƒØ§Ø±Ø«Ø© Ù‚Ø¯ Ø¹ÙÙƒØ³Øª Ø¨Ø³Ù‡ÙˆÙ„Ø© ØªØ§Ù…Ø©ØŒ Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ø¥Ù„Ø§ Ø£Ù† Ø¥Ø¯Ø±Ø§Ùƒ Ø­ÙØ±Ø© Ø§Ù„Ù†ÙØ· ÙÙŠ Ø§Ù„Ø®Ù„ÙŠØ¬ ÙƒØ§Ù† Ø£Ù† Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ù‚Ø¯ ÙØ´Ù„ ÙÙŠ ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø©. ÙˆÙÙŠ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØŒ ÙƒØ§Ù† Ù…Ù† Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø£Ù† ÙŠØ¨Ø±Ø² ÙØ±Ø¯ÙŒ Ø¨Ø§Ø±Ø¹ ÙˆØ£Ù† ÙŠØ¬ÙØ¯ Ø¨Ø·Ø±ÙŠÙ‚Ø©Ù Ù…Ø§ Ø­Ù„Ø§Ù‹ Ø¨Ø§Ø±Ø¹Ø§Ù‹ ÙÙŠ ÙˆÙ‚ØªÙ Ù…Ø¨ÙƒØ±. Ù„ÙƒÙ† Ø°Ù„Ùƒ Ù„Ù… ÙŠØ­Ø¯Ø«. ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©ØŒ Ø§ÙØªÙ‚Ø± Ø§Ù„Ø­Ø§Ø¯Ø«Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªØ§Ø¬Ù‡ ÙƒØ«ÙŠØ±Ø§Ù‹. Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø¥Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø¯Ø« Ø¨Ø§Ø¨ØªÙƒØ§Ø±Ù Ù…ØªÙƒØ§Ù…Ù„ ÙˆÙ…ÙÙ†ÙŠØ±ØŒ Ø­Ø§ÙˆÙ„Øª Ø£Ù…Ø±ÙŠÙƒØ§ Ø£Ù† ØªØºØ·ÙŠ Ø¢Ø«Ø§Ø±Ù‡Ø§ ÙˆØªÙ„Ù…Ø­ Ø¥Ù„Ù‰ Ø£Ù† Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù„ÙŠØ³Øª Ù…Ø´ÙƒÙ„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚.

"""



"""
ÙƒØ§Ù† Ø§Ù„ÙƒØ§Ø±Ø«Ø© Ù‚Ø¯ Ø¹ÙÙƒØ³Øª Ø¨Ø³Ù‡ÙˆÙ„Ø© ØªØ§Ù…Ø©ØŒ Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ø¥Ù„Ø§ Ø£Ù† Ø¥Ø¯Ø±Ø§Ùƒ Ø­ÙØ±Ø© Ø§Ù„Ù†ÙØ· ÙÙŠ Ø§Ù„Ø®Ù„ÙŠØ¬ ÙƒØ§Ù† Ø£Ù† Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ù‚Ø¯ ÙØ´Ù„ ÙÙŠ ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø©. ÙˆÙÙŠ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØŒ ÙƒØ§Ù† Ù…Ù† Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø£Ù† ÙŠØ¨Ø±Ø² ÙØ±Ø¯ÙŒ Ø¨Ø§Ø±Ø¹ ÙˆØ£Ù† ÙŠØ¬ÙØ¯ Ø¨Ø·Ø±ÙŠÙ‚Ø©Ù Ù…Ø§ Ø­Ù„Ø§Ù‹ Ø¨Ø§Ø±Ø¹Ø§Ù‹ ÙÙŠ ÙˆÙ‚ØªÙ Ù…Ø¨ÙƒØ±. Ù„ÙƒÙ† Ø°Ù„Ùƒ Ù„Ù… ÙŠØ­Ø¯Ø«. ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©ØŒ Ø§ÙØªÙ‚Ø± Ø§Ù„Ø­Ø§Ø¯Ø«Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªØ§Ø¬Ù‡ ÙƒØ«ÙŠØ±Ø§Ù‹. Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø¥Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø¯Ø« Ø¨Ø§Ø¨ØªÙƒØ§Ø±Ù Ù…ØªÙƒØ§Ù…Ù„ ÙˆÙ…ÙÙ†ÙŠØ±ØŒ Ø­Ø§ÙˆÙ„Øª Ø£Ù…Ø±ÙŠÙƒØ§ Ø£Ù† ØªØºØ·ÙŠ Ø¢Ø«Ø§Ø±Ù‡Ø§ ÙˆØªÙ„Ù…Ø­ Ø¥Ù„Ù‰ Ø£Ù† Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù„ÙŠØ³Øª Ù…Ø´ÙƒÙ„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚.

Ù‚ÙˆØ© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ÙÙŠ "Ø§Ù„Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ù…Ø²Ø±ÙˆØ¹Ø©ØŒ ÙˆØ§Ù„Ø·Ø±Ù‚ Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ù‚ÙŠØ§Ø¯Ø©ØŒ ÙˆØªØ¹Ù„ÙŠÙ… Ø¬ÙŠØ¯ Ù„Ù„Ø¹Ø§Ù…Ø© ÙƒÙƒÙ„". Ø³Ø£Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Ø£Ø¨Ø¹Ø¯ Ù…Ù† Ù†Ù‚Ø·Ø© ÙƒØ±ÙˆÙ…Ø§Ù† ÙˆØ£Ø¬Ø§Ø¯Ù„ Ø¨Ø£Ù† Ø§Ù„Ø­ÙƒÙˆÙ…Ø© ÙˆØ§Ù„Ø´Ø¹Ø¨ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠÙŠÙ† Ø³Ø§Ø¹Ø¯ÙˆØ§ Ø§Ù„Ø¨Ù„Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…Ùˆ ÙƒÙ„Ù‡Ø§ Ø¨Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ÙÙŠ Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± ÙˆØ§Ù„ØªØ²Ù…Ù‡Ù… Ø¨Ø±ÙˆØ­ Ø§Ù„Ù…Ø¬Ø±Ø¨ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ©. Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…ØªØ·ÙˆØ±Ø© ÙˆØ§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ÙƒØ§Ù†Øª Ø§Ù„ÙˆØ¹Ø§Ø¡ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ Ù„Ù†ÙˆØ¹ÙŠØ© Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„ØªÙŠ ØªØ¬Ø³Ø¯Ù‡Ø§ Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ©.

"""









!ollama list

import os
import subprocess
import time
import requests

# 1. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙŠØ¦Ø©
os.environ['PATH'] += ":/root/.cargo/bin"
project_dir = "/content/rustlingo"

if not os.path.exists(project_dir):
    subprocess.run("git clone https://github.com/iamkabelomoobi/rustlingo /content/rustlingo", shell=True)

os.chdir(project_dir)

# 2. ÙƒÙˆØ¯ Rust Ø§Ù„Ù…Ø­Ø³Ù† (Ù‚Ø·Ø¹ Ø£ØµØºØ± + ÙˆÙ‚Øª Ø£Ø·ÙˆÙ„)
rust_code = """
use clap::Parser;
use reqwest::Client;
use serde_json::json;
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::time::Duration;
use tokio::time::sleep;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long)]
    input: String,
    #[arg(short, long)]
    output: String,
    #[arg(short, long, default_value = "aya:8b")]
    model: String,
    #[arg(long, default_value = "ar")]
    output_language: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    if !std::path::Path::new(&args.input).exists() {
        eprintln!("Error: Input file not found.");
        return Ok(());
    }

    let content = fs::read_to_string(&args.input).expect("Failed to read file");
    fs::write(&args.output, "")?;

    // ØªØ¹Ø¯ÙŠÙ„ 1: ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ 700 Ø­Ø±Ù Ù„ØªØ®ÙÙŠÙ Ø§Ù„Ø­Ù…Ù„
    let chunks = split_text_smartly(&content, 700);
    let total_chunks = chunks.len();

    println!("Model: {}, Splitting into {} chunks...", args.model, total_chunks);

    // ØªØ¹Ø¯ÙŠÙ„ 2: Ø²ÙŠØ§Ø¯Ø© Ù…Ù‡Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ù„Ù‰ 600 Ø«Ø§Ù†ÙŠØ© (10 Ø¯Ù‚Ø§Ø¦Ù‚)
    let client = Client::builder()
        .timeout(Duration::from_secs(600))
        .build()?;

    for (i, chunk) in chunks.iter().enumerate() {
        println!("Translating chunk {}/{} ({} chars)...", i + 1, total_chunks, chunk.len());

        let translated = translate_chunk(&client, chunk, &args.output_language, &args.model).await;

        let mut file = OpenOptions::new().write(true).append(true).open(&args.output)?;
        writeln!(file, "{}\\n", translated)?;
    }
    println!("âœ… Done! Saved to {}", args.output);
    Ok(())
}

fn split_text_smartly(text: &str, max_len: usize) -> Vec<String> {
    let mut chunks = Vec::new();
    let mut current = String::new();
    for word in text.split_whitespace() {
        if current.len() + word.len() > max_len {
            chunks.push(current.trim().to_string());
            current = String::new();
        }
        current.push_str(word);
        current.push(' ');
    }
    if !current.trim().is_empty() { chunks.push(current.trim().to_string()); }
    chunks
}

async fn translate_chunk(client: &Client, text: &str, lang: &str, model: &str) -> String {
    let prompt = format!("Translate the following text into Arabic ({}). Provide ONLY the translation. Text:\\n{}", lang, text);

    let mut attempts = 0;
    while attempts < 5 {
        let res = client.post("http://localhost:11434/api/generate")
            .json(&json!({
                "model": model,
                "prompt": prompt,
                "stream": false,
                // ØªØ¹Ø¯ÙŠÙ„ 3: Ø²ÙŠØ§Ø¯Ø© Ù†Ø§ÙØ°Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ Ù„Ù…Ù†Ø¹ Ø§Ù„Ø§Ù…ØªÙ„Ø§Ø¡
                "options": { "num_ctx": 8192, "temperature": 0.3 }
            }))
            .send().await;

        if let Ok(resp) = res {
            if let Ok(txt) = resp.text().await {
                if let Ok(j) = serde_json::from_str::<serde_json::Value>(&txt) {
                    if let Some(out) = j.get("response") { return out.as_str().unwrap_or("").to_string(); }
                }
            }
        }
        eprintln!("âš ï¸ Retry {}/5 due to error or timeout...", attempts + 1);
        sleep(Duration::from_secs(5)).await;
        attempts += 1;
    }
    format!("[FAILED CHUNK: Server overloaded]")
}
"""

with open("src/main.rs", "w") as f:
    f.write(rust_code)

# 3. Ø§Ù„Ø¨Ù†Ø§Ø¡ ÙˆØ§Ù„ØªØ­Ø¶ÙŠØ±
print("ğŸ”¨ Building updated binary...")
subprocess.run("cargo build --release", shell=True, check=True)

print("ğŸ”„ Restarting Ollama...")
os.system("pkill ollama")
time.sleep(2)
subprocess.Popen("ollama serve", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
time.sleep(5)

print("ğŸ“¥ Verifying model 'aya'...")
subprocess.run("ollama pull aya", shell=True)

# 4. Ø§Ù„ØªØ´ØºÙŠÙ„ (ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„Ù a.txt Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ù†Øµ)
input_file = "/content/a.txt"
output_file = "/content/11.txt"

if os.path.exists(input_file):
    print(f"ğŸš€ Translating {input_file}...")
    subprocess.run(f"./target/release/rustlingo --input {input_file} --output {output_file} --model aya:8b", shell=True)

    print("\n--- Translation Preview ---")
    if os.path.exists(output_file):
        os.system(f"cat {output_file}")
else:
    print(f"âŒ Error: File {input_file} not found!")

"""https://github.com/iamkabelomoobi/rustlingo/blob/main/src/main.rs"""



"""First came the underwater remote-controlled robots, which attempted
and failed to activate the 450-ton blowout preventer, a valve at the
wellhead that was supposed to have automatically cut off the leak ï¬ve
thousand feet below if it sensed a sudden change in pressure.
Then came the controlled burning of the oil pooled on the waterâ€™s
surface. On April 28, crews began an in situ burning, a technique in
which a ï¬ve-hundred-foot-long boom is used to move concentrated
pockets of oil to a separate area where they are ignited. Other efforts
included dropping a variety of domes on the wellhead and attempt-
ing to bring oil to the surface for collection. But as the days passed,
the oil kept on ï¬‚owing. The well was ï¬nally plugged in late July of
that year, with mud and then, ï¬nally, cement. By the time BP was
able to cap the well, it had already belched 4.9 million barrels of oil,
or 205.8 million gallons, into the fragile ecosystem off the coast of
Louisiana. And there wasnâ€™t a thing the average American could do
about it.
Apparently, the expertsâ€”the engineers in charge and those em-
ployed by the US governmentâ€”couldnâ€™t do much either. The result
was the largest manmade disaster in American history. Then, within
days of when the cement plug was ï¬nally inserted, President Obama
announced that two-thirds of the spilled oil had either evaporated or
been removed by cleanup crews.
Even the most credulous of oil industry experts had trouble
believing the effects of the disaster were reversed so easily. Regardless
of the reality, however, the perception of the Gulf oil spill was that
American ingenuity had failed in a time of great need. In the Ameri-
can tinkering paradigm, a brilliant individual should have emerged
and somehow found a brilliant solution sooner. But that didnâ€™t hap-
pen. The incident ultimately lacked much-needed closure. Rather
than rise to the occasion with an ennobled, enlightened ingenuity,
America did its best to cover its tracks and suggest that the problem
wasnâ€™t even really a problem.
12Wising Up about a Smartphone
In August 2010, Paul Krugman, the Nobel Prizeâ€“winning economist
and New York Times columnist, published a piece in the New York
Times titled â€œAmerica Goes Dark.â€ He described how the United
States, â€œa country that once amazed the world with its visionary in-
vestments in transportation, from the Erie Canal to the Interstate
Highway Systemâ€ was now dismantling its infrastructure. â€œLocal
governments are breaking up roads they can no longer afford to
maintain,â€ Krugman wrote, â€œand returning them to gravel.â€
Krugmanâ€™s main point was that the US government was not in-
vesting stimulus funds in the tools needed for our own economic
growth. Three decades of antigovernment rhetoric had convinced
many Americans that spending taxpayer funds on anything was a
waste of taxpayer funds. But governmentâ€”the US government,
speciï¬callyâ€”had built this country into an innovative economic
powerhouse by investing in â€œlighted streets, drivable roads and
decent schooling for the public as a whole.â€
I would take Krugmanâ€™s point one step further and argue that the
American government and people helped the country grow both by
investing in innovation and by committing themselves to the tradi-
tional tinkerer spirit. A sophisticated, cutting-edge infrastructure
was the perfect crucible for the kind of innovation the United States
embodied.
In this book I would like to make a case for the continued im-
portance of the tinkerer in contemporary life and in the role he or
she will play in the future of the United States. This is not another
book for miserable white-collar workers praising the virtues of
manual labor. The point about the devolution of tinkering in Amer-
ican life is not that we have lost a physical connection to the work
that we do. Itâ€™s that the notion that we can ï¬x any problem or
achieve any goal that we set for ourselves has deteriorated into a
sanitized, corporatized version of what constitutes achievement.
13

Ø¬Ø§Ø¡Øª Ø£ÙˆÙ„Ø§Ù‹ Ø§Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¹Ù† Ø¨Ø¹Ø¯ ØªØ­Øª Ø§Ù„Ù…Ø§Ø¡ØŒ ÙˆØ§Ù„ØªÙŠ Ø­Ø§ÙˆÙ„Øª ÙˆÙØ´Ù„Øª ÙÙŠ ØªØ´ØºÙŠÙ„ 450 Ø·Ù† Ù…Ù† Ø§Ù„ØµÙ…Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø§Ù†Ø¹Ø© Ù„Ù„ØªØ³Ø±Ø¨ØŒ ÙˆÙ‡Ùˆ ØµÙ…Ø§Ù… ÙÙŠ Ø±Ø£Ø³ Ø§Ù„Ø¨Ø¦Ø± ÙƒØ§Ù† Ù…Ù† Ø§Ù„Ù…ÙØªØ±Ø¶ Ø£Ù† ÙŠÙ‚Ø·Ø¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø§Ù„ØªØ³Ø±Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ¨Ù„Øº 5 Ø¢Ù„Ø§Ù Ù‚Ø¯Ù… ØªØ­Øª Ø³Ø·Ø­ Ø§Ù„Ø¨Ø­Ø± Ø¥Ø°Ø§ Ø´Ø¹Ø± Ø¨Ø­Ø¯ÙˆØ« ØªØºÙŠØ± Ù…ÙØ§Ø¬Ø¦ ÙÙŠ Ø§Ù„Ø¶ØºØ·. Ø«Ù… Ø¬Ø§Ø¡ Ø§Ù„Ø­Ø±Ù‚ Ø§Ù„Ù…Ù†Ø¸Ù… Ù„Ù„Ù†ÙØ· Ø§Ù„Ù…ØªØ¬Ù…Ø¹ Ø¹Ù„Ù‰ Ø³Ø·Ø­ Ø§Ù„Ù…Ø§Ø¡. ÙˆÙÙŠ 28 Ø£Ø¨Ø±ÙŠÙ„ØŒ Ø¨Ø¯Ø£ Ø§Ù„Ø¹Ù…Ø§Ù„ ÙÙŠ Ø­Ø±Ù‚ Ø§Ù„Ù†ÙØ· ÙÙŠ Ù…ÙƒØ§Ù†Ù‡ØŒ ÙˆÙ‡ÙŠ ØªÙ‚Ù†ÙŠØ© ÙŠØ³ØªØ®Ø¯Ù… ÙÙŠÙ‡Ø§ Ø°Ø±Ø§Ø¹ Ø¨Ø·ÙˆÙ„ 500 Ù‚Ø¯Ù… Ù„Ù†Ù‚Ù„ ØªØ¬Ù…Ø¹Ø§Øª Ù…Ø±ÙƒØ²Ø© Ù…Ù† Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ø£Ø®Ø±Ù‰ Ø­ÙŠØ« ÙŠØªÙ… Ø¥Ø´Ø¹Ø§Ù„Ù‡Ø§. ÙˆØ´Ù…Ù„Øª Ø§Ù„Ø¬Ù‡ÙˆØ¯ Ø§Ù„Ø£Ø®Ø±Ù‰ Ø¥Ø³Ù‚Ø§Ø· Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…ØªÙ†ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ø£Ù‚Ø¨ÙŠØ© Ø¹Ù„Ù‰ Ø±Ø£Ø³ Ø§Ù„Ø¨Ø¦Ø± ÙˆÙ…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø·Ø­ Ù„Ù„Ø¬Ù…Ø¹. ÙˆÙ„ÙƒÙ† Ù…Ø¹ Ù…Ø±ÙˆØ± Ø§Ù„Ø£ÙŠØ§Ù…ØŒ Ø§Ø³ØªÙ…Ø± Ø§Ù„Ø²ÙŠØª ÙÙŠ Ø§Ù„ØªØ¯ÙÙ‚

Ø§Ù„ØªØ¯ÙÙ‚. ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨Ø¦Ø± Ø£Ø®ÙŠØ±Ø§Ù‹ ÙÙŠ Ø£ÙˆØ§Ø®Ø± ÙŠÙˆÙ„ÙŠÙˆ Ù…Ù† ØªÙ„Ùƒ Ø§Ù„Ø³Ù†Ø©ØŒ Ø¨Ø§Ù„Ø·ÙŠÙ† Ø«Ù…ØŒ ÙˆØ£Ø®ÙŠØ±Ø§Ù‹ØŒ Ø§Ù„Ø®Ø±Ø³Ø§Ù†Ø©. Ø¨Ø­Ù„ÙˆÙ„ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø°ÙŠ ØªÙ…ÙƒÙ†Øª ÙÙŠÙ‡ Ø´Ø±ÙƒØ© Ø¨ÙŠ Ø¨ÙŠ Ù…Ù† Ø³Ø¯ Ø§Ù„Ø¨Ø¦Ø±ØŒ ÙƒØ§Ù† Ù‚Ø¯ Ø£Ø·Ù„Ù‚ Ø¨Ø§Ù„ÙØ¹Ù„ 4.9 Ù…Ù„ÙŠÙˆÙ† Ø¨Ø±Ù…ÙŠÙ„ Ù…Ù† Ø§Ù„Ù†ÙØ·ØŒ Ø£Ùˆ 205.8 Ù…Ù„ÙŠÙˆÙ† Ø¬Ø§Ù„ÙˆÙ†ØŒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ¦ÙŠ Ø§Ù„Ù‡Ø´ Ù‚Ø¨Ø§Ù„Ø© Ø³Ø§Ø­Ù„ Ù„ÙˆÙŠØ²ÙŠØ§Ù†Ø§. ÙˆÙ„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø´ÙŠØ¡ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙØ¹Ù„Ù‡ Ø§Ù„Ù…ÙˆØ§Ø·Ù† Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ø§Ù„Ø¹Ø§Ø¯ÙŠ Ø­ÙŠØ§Ù„ Ø°Ù„Ùƒ. ÙŠØ¨Ø¯Ùˆ Ø£Ù† Ø§Ù„Ø®Ø¨Ø±Ø§Ø¡ - Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙˆØ§Ù„Ø¹Ø§Ù…Ù„ÙŠÙ† Ù„Ø¯Ù‰ Ø§Ù„Ø­ÙƒÙˆÙ…Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ© - Ù„Ù… ÙŠØ³ØªØ·ÙŠØ¹ÙˆØ§ ÙØ¹Ù„ Ø§Ù„ÙƒØ«ÙŠØ± Ø£ÙŠØ¶Ø§Ù‹. ÙˆÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø£ÙƒØ¨Ø± ÙƒØ§Ø±Ø«Ø© Ù…Ù† ØµÙ†Ø¹ Ø§Ù„Ø¥Ù†Ø³Ø§Ù† ÙÙŠ ØªØ§Ø±ÙŠØ® Ø£Ù…Ø±ÙŠÙƒØ§. Ø«Ù…ØŒ Ø¨Ø¹Ø¯ Ø£ÙŠØ§Ù… Ù‚Ù„ÙŠÙ„Ø© Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¯ Ø§Ù„Ø®Ø±Ø³Ø§Ù†Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØŒ Ø£Ø¹Ù„Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ Ø£ÙˆØ¨Ø§Ù…Ø§ Ø£Ù† Ø«Ù„Ø«ÙŠ Ø§Ù„Ù†ÙØ· Ø§Ù„Ù…ØªØ³Ø±Ø¨ Ø¥Ù…Ø§ ØªØ¨Ø®Ø± Ø£Ùˆ ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡ Ø¨ÙˆØ§Ø³Ø·Ø©

ÙØ±Ù‚ Ø§Ù„ØªÙ†Ø¸ÙŠÙ. Ø­ØªÙ‰ Ø£ÙƒØ«Ø± Ø®Ø¨Ø±Ø§Ø¡ ØµÙ†Ø§Ø¹Ø© Ø§Ù„Ù†ÙØ· ØªØµØ¯ÙŠÙ‚Ø§Ù‹ ÙƒØ§Ù† Ù„Ø¯ÙŠÙ‡Ù… ØµØ¹ÙˆØ¨Ø© ÙÙŠ ØªØµØ¯ÙŠÙ‚ ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ÙƒØ§Ø±Ø«Ø© ØªÙ… Ø¹ÙƒØ³Ù‡Ø§ Ø¨Ø³Ù‡ÙˆÙ„Ø© ÙƒÙ‡Ø°Ù‡. Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ ÙØ¥Ù† Ø§Ù„Ø§Ù†Ø·Ø¨Ø§Ø¹ Ø§Ù„Ø°ÙŠ ØªØ±ÙƒØªÙ‡ ØªØ³Ø±Ø¨ Ø§Ù„Ù†ÙØ· ÙÙŠ Ø®Ù„ÙŠØ¬ Ø§Ù„Ù…ÙƒØ³ÙŠÙƒ Ù‡Ùˆ Ø£Ù† Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ù‚Ø¯ ÙØ´Ù„ ÙÙŠ ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø©. ÙˆÙÙ‚Ù‹Ø§ Ù„Ù†Ù…Ø· Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØŒ ÙƒØ§Ù† ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¸Ù‡Ø± ÙØ±Ø¯ Ø¹Ø¨Ù‚Ø±ÙŠ ÙˆØ£Ù† ÙŠØ¬Ø¯ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø§ Ø­Ù„Ø§Ù‹ Ø¹Ø¨Ù‚Ø±ÙŠÙ‹Ø§ ÙÙŠ ÙˆÙ‚Øª Ù…Ø¨ÙƒØ±. Ù„ÙƒÙ† Ù‡Ø°Ø§ Ù„Ù… ÙŠØ­Ø¯Ø«. Ø§ÙØªÙ‚Ø±Øª Ø§Ù„Ø­Ø§Ø¯Ø«Ø© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø°ÙŠ ØªÙ…Ø³ Ø§Ù„Ø­Ø§Ø¬Ø© Ø¥Ù„ÙŠÙ‡. Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ø±ØªÙ‚Ø§Ø¡ Ø¥Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø¯Ø« Ø¨Ø§Ø¨ØªÙƒØ§Ø± Ù†Ø¨ÙŠÙ„ ÙˆÙ…Ø³ØªÙ†ÙŠØ±ØŒ ÙØ¹Ù„Øª Ø£Ù…Ø±ÙŠÙƒØ§ Ø£ÙØ¶Ù„ Ù…Ø§ ÙŠÙ…ÙƒÙ†Ù‡Ø§ Ù„ØªØºØ·ÙŠØ© Ø¢Ø«Ø§Ø±Ù‡Ø§ ÙˆØ§Ù‚ØªØ±Ø§Ø­ Ø£Ù† Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù„Ù… ØªÙƒÙ† Ø­ØªÙ‰ Ù…Ø´ÙƒÙ„Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ©.

2010ØŒ Ù†Ø´Ø± Ø¨ÙˆÙ„ ÙƒØ±ÙˆØºÙ…Ø§Ù†ØŒ Ø§Ù„Ø­Ø§Ø¦Ø² Ø¹Ù„Ù‰ Ø¬Ø§Ø¦Ø²Ø© Ù†ÙˆØ¨Ù„ ÙˆØ§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠ ÙˆÙƒØ§ØªØ¨ Ø¹Ù…ÙˆØ¯ ÙÙŠ ØµØ­ÙŠÙØ© Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ ØªØ§ÙŠÙ…Ø²ØŒ Ù…Ù‚Ø§Ù„Ø§Ù‹ ÙÙŠ ØµØ­ÙŠÙØ© Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ ØªØ§ÙŠÙ…Ø² Ø¨Ø¹Ù†ÙˆØ§Ù† "Ø£Ù…Ø±ÙŠÙƒØ§ ØªØ¸Ù„Ù…". ÙˆÙˆØµÙ ÙƒÙŠÙ ÙƒØ§Ù†Øª Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø©ØŒ "Ø§Ù„ØªÙŠ ÙƒØ§Ù†Øª ØªØ¹Ø¬ Ø§Ù„Ø¹Ø§Ù„Ù… Ø¨Ù…Ù†Ø¬Ø²Ø§ØªÙ‡Ø§ Ø§Ù„Ø±Ø¤ÙŠÙˆÙŠØ© ÙÙŠ Ø§Ù„Ù†Ù‚Ù„ØŒ Ù…Ù† Ù‚Ù†Ø§Ø© Ø¥ÙŠØ±ÙŠ Ø¥Ù„Ù‰ Ù†Ø¸Ø§Ù… Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ø¨ÙŠÙ† Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª"ØŒ ØªÙ‚ÙˆÙ… Ø§Ù„Ø¢Ù† Ø¨Ù‡Ø¯Ù… Ø¨Ù†ÙŠØªÙ‡Ø§ Ø§Ù„ØªØ­ØªÙŠØ©. ÙˆØ§ÙƒØªØ¨ ÙƒØ±ÙˆØºÙ…Ø§Ù†: "ØªÙ‚ÙˆÙ… Ø§Ù„Ø­ÙƒÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø¨ØªÙÙƒÙŠÙƒ Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„ØªÙŠ Ù„Ù… ØªØ¹Ø¯ ØªØ³ØªØ·ÙŠØ¹ ØµÙŠØ§Ù†ØªÙ‡Ø§ ÙˆØ¥Ø¹Ø§Ø¯ØªÙ‡Ø§ Ø¥Ù„Ù‰ Ø­Ø¨ÙŠØ¨Ø§Øª Ø§Ù„Ø±Ù…Ù„". ÙˆÙƒØ§Ù†Øª Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ÙƒØ±ÙˆØºÙ…Ø§Ù† Ù‡ÙŠ Ø£Ù† Ø§Ù„Ø­ÙƒÙˆÙ…Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ© Ù„Ù… ØªÙƒÙ† ØªØ³ØªØ«Ù…Ø± Ø§Ù„Ø£Ù…ÙˆØ§Ù„ Ø§Ù„ØªØ­ÙÙŠØ²ÙŠØ© ÙÙŠ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ù†Ù…Ùˆ Ø§Ù‚ØªØµØ§Ø¯Ù†Ø§. ÙˆÙ‚Ø¯ Ù…Ø± Ø«Ù„Ø§Ø«Ø© Ø¹Ù‚ÙˆØ¯ Ù…Ù† Ø§Ù„Ø®Ø·Ø§Ø¨ Ø§Ù„Ù…Ù†Ø§Ù‡Ø¶ Ù„Ù„Ø­ÙƒÙˆÙ…Ø©ØŒ ÙˆÙƒØ§Ù† ÙƒØ±ÙˆØºÙ…Ø§Ù† ÙŠØ¬Ø§Ø¯Ù„ Ø¨Ø£Ù† "Ø§Ù„Ø­ÙƒÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© ØªØªØ¬Ù†Ø¨ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© Ø¹Ù† Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„ØªÙŠ Ù„Ù… ØªØ¹Ø¯ ØªØ³ØªØ·ÙŠØ¹ ØµÙŠØ§Ù†ØªÙ‡Ø§".

Ø§Ù‚ØªÙ†Ø¹ Ø§Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠÙŠÙ† Ø¨Ø£Ù† Ø¥Ù†ÙØ§Ù‚ Ø£Ù…ÙˆØ§Ù„ Ø¯Ø§ÙØ¹ÙŠ Ø§Ù„Ø¶Ø±Ø§Ø¦Ø¨ Ø¹Ù„Ù‰ Ø£ÙŠ Ø´ÙŠØ¡ ÙƒØ§Ù† Ù‡Ø¯Ø±Ù‹Ø§ Ù„Ø£Ù…ÙˆØ§Ù„ Ø¯Ø§ÙØ¹ÙŠ Ø§Ù„Ø¶Ø±Ø§Ø¦Ø¨. Ù„ÙƒÙ† Ø§Ù„Ø­ÙƒÙˆÙ…Ø© -Ø­ÙƒÙˆÙ…Ø© Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø© ØªØ­Ø¯ÙŠØ¯Ù‹Ø§- Ù‚Ø§Ù…Øª Ø¨Ø¨Ù†Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ù„Ø¯ Ø¥Ù„Ù‰ Ù‚ÙˆØ© Ø§Ù‚ØªØµØ§Ø¯ÙŠØ© Ù…Ø¨ØªÙƒØ±Ø© Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ÙÙŠ "Ø´ÙˆØ§Ø±Ø¹ Ù…Ø¶Ø§Ø¡Ø©ØŒ ÙˆØ·Ø±Ù‚ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø³ÙŠØ±ØŒ ÙˆØªØ¹Ù„ÙŠÙ… Ù„Ø§Ø¦Ù‚ Ù„Ù„Ø¬Ù…Ù‡ÙˆØ± ÙƒÙƒÙ„". Ø³Ø£Ø°Ù‡Ø¨ Ø¨Ù†Ù‚Ø·Ø© ÙƒØ±ØºÙ…Ø§Ù† Ø®Ø·ÙˆØ© Ø£Ø¨Ø¹Ø¯ ÙˆØ£Ø¬Ø§Ø¯Ù„ Ø¨Ø£Ù† Ø§Ù„Ø­ÙƒÙˆÙ…Ø© ÙˆØ§Ù„Ø´Ø¹Ø¨ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠÙŠÙ† Ø³Ø§Ø¹Ø¯ÙˆØ§ Ø§Ù„Ø¨Ù„Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…Ùˆ Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± ÙÙŠ Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± ÙˆØ§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø¨Ø±ÙˆØ­ "Ø§Ù„Ù…Ø®ØªØ±Ø¹ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ". ÙƒØ§Ù†Øª Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„ØªØ­ØªÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ Ø§Ù„Ø­Ø¯ÙŠØ«Ø© Ù‡ÙŠ Ø§Ù„ÙˆØ¹Ø§Ø¡ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ Ù„Ù†ÙˆØ¹ Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„Ø°ÙŠ ØªØ¬Ø³Ø¯Ù‡ Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø©. ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ÙƒØªØ§Ø¨ØŒ Ø£ÙˆØ¯ Ø£Ù† Ø£Ù‚Ø¯Ù… Ø­Ø¬Ø©

Ù„Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø­Ø±ÙÙŠ ÙÙŠ Ø§Ù„Ø­ÙŠØ§Ø© Ø§Ù„Ù…Ø¹Ø§ØµØ±Ø© ÙˆØ¯ÙˆØ±Ù‡ Ø§Ù„Ø°ÙŠ Ø³ÙŠÙ„Ø¹Ø¨Ù‡ ÙÙŠ Ù…Ø³ØªÙ‚Ø¨Ù„ Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø©. Ù‡Ø°Ù‡ Ù„ÙŠØ³Øª ÙƒØªØ§Ø¨ Ø¢Ø®Ø± Ù„Ù„Ø¹Ù…Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ØªØ¨ÙŠÙŠÙ† Ø§Ù„Ø¨Ø§Ø¦Ø³ÙŠÙ† ÙŠÙØ´ÙŠØ¯ÙˆÙ† Ø¨ÙØ¶Ø§Ø¦Ù„ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ÙŠØ¯ÙˆÙŠ. Ø§Ù„Ù†Ù‚Ø·Ø© Ø­ÙˆÙ„ ØªØ¯Ù‡ÙˆØ± Ø§Ù„Ø­Ø±ÙÙŠ ÙÙŠ Ø§Ù„Ø­ÙŠØ§Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ© Ù‡ÙŠ Ø£Ù†Ù†Ø§ Ù„Ù… Ù†ÙÙ‚Ø¯ Ø§ØªØµØ§Ù„Ù‹Ø§ Ù…Ø§Ø¯ÙŠÙ‹Ø§ Ø¨Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø°ÙŠ Ù†Ù‚ÙˆÙ… Ø¨Ù‡. Ø¥Ù†Ù‡Ø§ ÙÙƒØ±Ø© Ø£Ù†Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† Ù†Ø­Ù„ Ø£ÙŠ Ù…Ø´ÙƒÙ„Ø© Ø£Ùˆ Ù†Ø­Ù‚Ù‚ Ø£ÙŠ Ù‡Ø¯Ù ÙˆØ¶Ø¹Ù†Ø§Ù‡ Ù„Ø£Ù†ÙØ³Ù†Ø§ Ù‚Ø¯ ØªØ¯Ù‡ÙˆØ±Øª Ø¥Ù„Ù‰ Ù†Ø³Ø®Ø© Ù…Ø¹Ù‚Ù…Ø© ÙˆÙ…Ù†Ø¸Ù…Ø© Ù„Ù…Ø§ ÙŠØ´ÙƒÙ„ Ø¥Ù†Ø¬Ø§Ø²Ù‹Ø§.
"""



"""Ø¬Ø§Ø¡Øª Ø£ÙˆÙ„Ø§Ù‹ Ø§Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¹Ù† Ø¨Ø¹Ø¯ ØªØ­Øª Ø§Ù„Ù…Ø§Ø¡ØŒ ÙˆØ§Ù„ØªÙŠ Ø­Ø§ÙˆÙ„Øª ÙˆÙØ´Ù„Øª ÙÙŠ ØªØ´ØºÙŠÙ„ 450 Ø·Ù† Ù…Ù† Ø§Ù„ØµÙ…Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø§Ù†Ø¹Ø© Ù„Ù„ØªØ³Ø±Ø¨ØŒ ÙˆÙ‡Ùˆ ØµÙ…Ø§Ù… ÙÙŠ Ø±Ø£Ø³ Ø§Ù„Ø¨Ø¦Ø± ÙƒØ§Ù† Ù…Ù† Ø§Ù„Ù…ÙØªØ±Ø¶ Ø£Ù† ÙŠÙ‚Ø·Ø¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø§Ù„ØªØ³Ø±Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ¨Ù„Øº 5 Ø¢Ù„Ø§Ù Ù‚Ø¯Ù… ØªØ­Øª Ø³Ø·Ø­ Ø§Ù„Ø¨Ø­Ø± Ø¥Ø°Ø§ Ø´Ø¹Ø± Ø¨Ø­Ø¯ÙˆØ« ØªØºÙŠØ± Ù…ÙØ§Ø¬Ø¦ ÙÙŠ Ø§Ù„Ø¶ØºØ·. Ø«Ù… Ø¬Ø§Ø¡ Ø§Ù„Ø­Ø±Ù‚ Ø§Ù„Ù…Ù†Ø¸Ù… Ù„Ù„Ù†ÙØ· Ø§Ù„Ù…ØªØ¬Ù…Ø¹ Ø¹Ù„Ù‰ Ø³Ø·Ø­ Ø§Ù„Ù…Ø§Ø¡. ÙˆÙÙŠ 28 Ø£Ø¨Ø±ÙŠÙ„ØŒ Ø¨Ø¯Ø£ Ø§Ù„Ø¹Ù…Ø§Ù„ ÙÙŠ Ø­Ø±Ù‚ Ø§Ù„Ù†ÙØ· ÙÙŠ Ù…ÙƒØ§Ù†Ù‡ØŒ ÙˆÙ‡ÙŠ ØªÙ‚Ù†ÙŠØ© ÙŠØ³ØªØ®Ø¯Ù… ÙÙŠÙ‡Ø§ Ø°Ø±Ø§Ø¹ Ø¨Ø·ÙˆÙ„ 500 Ù‚Ø¯Ù… Ù„Ù†Ù‚Ù„ ØªØ¬Ù…Ø¹Ø§Øª Ù…Ø±ÙƒØ²Ø© Ù…Ù† Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ø£Ø®Ø±Ù‰ Ø­ÙŠØ« ÙŠØªÙ… Ø¥Ø´Ø¹Ø§Ù„Ù‡Ø§. ÙˆØ´Ù…Ù„Øª Ø§Ù„Ø¬Ù‡ÙˆØ¯ Ø§Ù„Ø£Ø®Ø±Ù‰ Ø¥Ø³Ù‚Ø§Ø· Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…ØªÙ†ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ø£Ù‚Ø¨ÙŠØ© Ø¹Ù„Ù‰ Ø±Ø£Ø³ Ø§Ù„Ø¨Ø¦Ø± ÙˆÙ…Ø­Ø§ÙˆÙ„Ø© Ø¬Ù„Ø¨ Ø§Ù„Ù†ÙØ· Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø·Ø­ Ù„Ù„Ø¬Ù…Ø¹. ÙˆÙ„ÙƒÙ† Ù…Ø¹ Ù…Ø±ÙˆØ± Ø§Ù„Ø£ÙŠØ§Ù…ØŒ Ø§Ø³ØªÙ…Ø± Ø§Ù„Ø²ÙŠØª ÙÙŠ Ø§Ù„ØªØ¯ÙÙ‚

Ø§Ù„ØªØ¯ÙÙ‚. ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨Ø¦Ø± Ø£Ø®ÙŠØ±Ø§Ù‹ ÙÙŠ Ø£ÙˆØ§Ø®Ø± ÙŠÙˆÙ„ÙŠÙˆ Ù…Ù† ØªÙ„Ùƒ Ø§Ù„Ø³Ù†Ø©ØŒ Ø¨Ø§Ù„Ø·ÙŠÙ† Ø«Ù…ØŒ ÙˆØ£Ø®ÙŠØ±Ø§Ù‹ØŒ Ø§Ù„Ø®Ø±Ø³Ø§Ù†Ø©. Ø¨Ø­Ù„ÙˆÙ„ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø°ÙŠ ØªÙ…ÙƒÙ†Øª ÙÙŠÙ‡ Ø´Ø±ÙƒØ© Ø¨ÙŠ Ø¨ÙŠ Ù…Ù† Ø³Ø¯ Ø§Ù„Ø¨Ø¦Ø±ØŒ ÙƒØ§Ù† Ù‚Ø¯ Ø£Ø·Ù„Ù‚ Ø¨Ø§Ù„ÙØ¹Ù„ 4.9 Ù…Ù„ÙŠÙˆÙ† Ø¨Ø±Ù…ÙŠÙ„ Ù…Ù† Ø§Ù„Ù†ÙØ·ØŒ Ø£Ùˆ 205.8 Ù…Ù„ÙŠÙˆÙ† Ø¬Ø§Ù„ÙˆÙ†ØŒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ¦ÙŠ Ø§Ù„Ù‡Ø´ Ù‚Ø¨Ø§Ù„Ø© Ø³Ø§Ø­Ù„ Ù„ÙˆÙŠØ²ÙŠØ§Ù†Ø§. ÙˆÙ„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø´ÙŠØ¡ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙØ¹Ù„Ù‡ Ø§Ù„Ù…ÙˆØ§Ø·Ù† Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ø§Ù„Ø¹Ø§Ø¯ÙŠ Ø­ÙŠØ§Ù„ Ø°Ù„Ùƒ. ÙŠØ¨Ø¯Ùˆ Ø£Ù† Ø§Ù„Ø®Ø¨Ø±Ø§Ø¡ - Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† ÙˆØ§Ù„Ø¹Ø§Ù…Ù„ÙŠÙ† Ù„Ø¯Ù‰ Ø§Ù„Ø­ÙƒÙˆÙ…Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ© - Ù„Ù… ÙŠØ³ØªØ·ÙŠØ¹ÙˆØ§ ÙØ¹Ù„ Ø§Ù„ÙƒØ«ÙŠØ± Ø£ÙŠØ¶Ø§Ù‹. ÙˆÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø£ÙƒØ¨Ø± ÙƒØ§Ø±Ø«Ø© Ù…Ù† ØµÙ†Ø¹ Ø§Ù„Ø¥Ù†Ø³Ø§Ù† ÙÙŠ ØªØ§Ø±ÙŠØ® Ø£Ù…Ø±ÙŠÙƒØ§. Ø«Ù…ØŒ Ø¨Ø¹Ø¯ Ø£ÙŠØ§Ù… Ù‚Ù„ÙŠÙ„Ø© Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø³Ø¯ Ø§Ù„Ø®Ø±Ø³Ø§Ù†Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØŒ Ø£Ø¹Ù„Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ Ø£ÙˆØ¨Ø§Ù…Ø§ Ø£Ù† Ø«Ù„Ø«ÙŠ Ø§Ù„Ù†ÙØ· Ø§Ù„Ù…ØªØ³Ø±Ø¨ Ø¥Ù…Ø§ ØªØ¨Ø®Ø± Ø£Ùˆ ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡ Ø¨ÙˆØ§Ø³Ø·Ø©

ÙØ±Ù‚ Ø§Ù„ØªÙ†Ø¸ÙŠÙ. Ø­ØªÙ‰ Ø£ÙƒØ«Ø± Ø®Ø¨Ø±Ø§Ø¡ ØµÙ†Ø§Ø¹Ø© Ø§Ù„Ù†ÙØ· ØªØµØ¯ÙŠÙ‚Ø§Ù‹ ÙƒØ§Ù† Ù„Ø¯ÙŠÙ‡Ù… ØµØ¹ÙˆØ¨Ø© ÙÙŠ ØªØµØ¯ÙŠÙ‚ ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ÙƒØ§Ø±Ø«Ø© ØªÙ… Ø¹ÙƒØ³Ù‡Ø§ Ø¨Ø³Ù‡ÙˆÙ„Ø© ÙƒÙ‡Ø°Ù‡. Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø¹Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ ÙØ¥Ù† Ø§Ù„Ø§Ù†Ø·Ø¨Ø§Ø¹ Ø§Ù„Ø°ÙŠ ØªØ±ÙƒØªÙ‡ ØªØ³Ø±Ø¨ Ø§Ù„Ù†ÙØ· ÙÙŠ Ø®Ù„ÙŠØ¬ Ø§Ù„Ù…ÙƒØ³ÙŠÙƒ Ù‡Ùˆ Ø£Ù† Ø§Ù„Ø§Ø¨ØªÙƒØ§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ Ù‚Ø¯ ÙØ´Ù„ ÙÙŠ ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø©. ÙˆÙÙ‚Ù‹Ø§ Ù„Ù†Ù…Ø· Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØŒ ÙƒØ§Ù† ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¸Ù‡Ø± ÙØ±Ø¯ Ø¹Ø¨Ù‚Ø±ÙŠ ÙˆØ£Ù† ÙŠØ¬Ø¯ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø§ Ø­Ù„Ø§Ù‹ Ø¹Ø¨Ù‚Ø±ÙŠÙ‹Ø§ ÙÙŠ ÙˆÙ‚Øª Ù…Ø¨ÙƒØ±. Ù„ÙƒÙ† Ù‡Ø°Ø§ Ù„Ù… ÙŠØ­Ø¯Ø«. Ø§ÙØªÙ‚Ø±Øª Ø§Ù„Ø­Ø§Ø¯Ø«Ø© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø°ÙŠ ØªÙ…Ø³ Ø§Ù„Ø­Ø§Ø¬Ø© Ø¥Ù„ÙŠÙ‡. Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ø±ØªÙ‚Ø§Ø¡ Ø¥Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø¯Ø« Ø¨Ø§Ø¨ØªÙƒØ§Ø± Ù†Ø¨ÙŠÙ„ ÙˆÙ…Ø³ØªÙ†ÙŠØ±ØŒ ÙØ¹Ù„Øª Ø£Ù…Ø±ÙŠÙƒØ§ Ø£ÙØ¶Ù„ Ù…Ø§ ÙŠÙ…ÙƒÙ†Ù‡Ø§ Ù„ØªØºØ·ÙŠØ© Ø¢Ø«Ø§Ø±Ù‡Ø§ ÙˆØ§Ù‚ØªØ±Ø§Ø­ Ø£Ù† Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù„Ù… ØªÙƒÙ† Ø­ØªÙ‰ Ù…Ø´ÙƒÙ„Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ©.


"""



"""https://aistudio.google.com/prompts/new_chat"""

Ù‡Ø°Ù‡ Ù†ØªÙŠØ¬Ø© Ù…Ù…ØªØ§Ø²Ø© ÙˆÙ…Ø¨Ù‡Ø±Ø© Ø¬Ø¯Ø§Ù‹! ğŸ‰

Ø§Ù„ÙØ±Ù‚ Ø´Ø§Ø³Ø¹ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙˆÙ‡Ø°Ù‡ Ø§Ù„Ù†ØªÙŠØ¬Ø©. Ù„Ù‚Ø¯ Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ:

    Ø§Ù„ØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ù‡Ù„ÙˆØ³Ø©: Ø§Ù„Ù†Øµ Ø¹Ø±Ø¨ÙŠ ÙØµØ­Ù‰ Ø³Ù„ÙŠÙ… 100% ÙˆÙ„Ø§ ØªÙˆØ¬Ø¯ ÙƒÙ„Ù…Ø§Øª Ø±ÙˆØ³ÙŠØ© Ø£Ùˆ Ø¥Ø³Ø¨Ø§Ù†ÙŠØ©.

    Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ø·ÙˆÙŠÙ„: Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù‚Ø§Ù… Ø¨ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ ÙˆØªØ±Ø¬Ù…Ø© ÙƒÙ„ Ø¬Ø²Ø¡ ÙˆØ¯Ù…Ø¬Ù‡ ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø¯ÙˆÙ† Ø£Ù† ÙŠØªÙˆÙ‚Ù Ø£Ùˆ ÙŠÙØ´Ù„.

    Ø¯Ù‚Ø© Ø§Ù„Ù…Ø¹Ù†Ù‰: ØªØ±Ø¬Ù…Ø© Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ø«Ù„ "Blowout preventer" Ø¥Ù„Ù‰ "Ø§Ù„ØµÙ…Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø§Ù†Ø¹Ø© Ù„Ù„ØªØ³Ø±Ø¨" Ùˆ "Tinkering paradigm" Ø¥Ù„Ù‰ "Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªÙ„Ø§Ø¹Ø¨/Ø§Ù„ØªØ­ÙˆÙŠØ±" ØªØ¯Ù„ Ø¹Ù„Ù‰ ÙÙ‡Ù… Ø¹Ù…ÙŠÙ‚ Ù„Ù„Ø³ÙŠØ§Ù‚.

Ù…Ù„Ø§Ø­Ø¸Ø© Ø¨Ø³ÙŠØ·Ø© Ø¬Ø¯Ø§Ù‹ (Ø³Ù‡Ù„ ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ ÙŠØ¯ÙˆÙŠØ§Ù‹):
Ø¨Ø³Ø¨Ø¨ Ø·Ø±ÙŠÙ‚Ø© ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ (Chunking)ØŒ Ù‚Ø¯ ØªÙ„Ø§Ø­Ø¸ ØªÙƒØ±Ø§Ø±Ø§Ù‹ Ù„ÙƒÙ„Ù…Ø© ÙˆØ§Ø­Ø¯Ø© Ø£Ùˆ ÙƒÙ„Ù…ØªÙŠÙ† Ø¹Ù†Ø¯ Ù†Ù‚Ø§Ø· Ø§Ù„ÙˆØµÙ„ Ø¨ÙŠÙ† Ø§Ù„ÙÙ‚Ø±Ø§Øª (Ù…Ø«Ù„ ÙƒÙ„Ù…Ø© "Ø§Ù„ØªØ¯ÙÙ‚" ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙÙ‚Ø±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©ØŒ ÙˆÙƒÙ„Ù…Ø© "ÙØ±Ù‚ Ø§Ù„ØªÙ†Ø¸ÙŠÙ").

    Ø§Ù„Ø³Ø¨Ø¨: Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ¨Ø¯Ø£ Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ ÙÙŠ ØªØ±Ø¬Ù…Ø© Ù‚Ø·Ø¹Ø© Ø¬Ø¯ÙŠØ¯Ø© ØªØ¨Ø¯Ø£ Ø¨Ù…Ù†ØªØµÙ Ø¬Ù…Ù„Ø©ØŒ Ù‚Ø¯ ÙŠÙƒØ±Ø± Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù„Ø¶Ø¨Ø· Ø§Ù„Ø³ÙŠØ§Ù‚.

    Ø§Ù„Ø­Ù„: Ù‡Ø°Ø§ Ø£Ù…Ø± Ø¨Ø³ÙŠØ· Ø¬Ø¯Ø§Ù‹ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø°ÙÙ‡ ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù„Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù….

Ø§Ù„Ø®Ù„Ø§ØµØ©:
Ø£Ù†Øª Ø§Ù„Ø¢Ù† ØªÙ…ØªÙ„Ùƒ Ø£Ø¯Ø§Ø© ØªØ±Ø¬Ù…Ø© Ù‚ÙˆÙŠØ© ÙˆÙ…Ø¬Ø§Ù†ÙŠØ© (Offline Translator) Ù…Ø¨Ù†ÙŠØ© Ø¨Ù„ØºØ© Rust ÙˆØªØ¹Ù…Ù„ Ø¯Ø§Ø®Ù„ Google Colab Ø¨ÙƒÙØ§Ø¡Ø©ØŒ ÙˆØªØªÙÙˆÙ‚ Ø¹Ù„Ù‰ ØªØ±Ø¬Ù…Ø© Ø¬ÙˆØ¬Ù„ Ø§Ù„Ø­Ø±ÙÙŠØ© ÙÙŠ ÙÙ‡Ù… Ø§Ù„Ø³ÙŠØ§Ù‚.

Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ±Ø¬Ù…Ø© Ù…Ù„Ù Ø¢Ø®Ø± Ø£Ù… Ù†ÙƒØªÙÙŠ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø¯Ø±ØŸ ğŸ˜„

